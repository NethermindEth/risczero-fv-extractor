Extracted IR for nonzero-example
Extracted IR for onehot-example1
Extracted IR for onehot-example2
Extracted IR for decode-example
Extracted IR for onehot-example20
IR extraction complete
Creating code files  
moved "%0" ←ₐ .Const 1 7
Proved optimised_behaviour1
moved "%1" ←ₐ .Get ⟨"in"⟩ 0 0 0
moved "%2" ←ₐ .Get ⟨"data"⟩ 0 0 0
Reordered witness code:
"%1" ←ₐ .Get ⟨"in"⟩ 0 0
"%4" ←ₐ ??₀⟨"%1"⟩
⟨"data"⟩[0] ←ᵢ ⟨"%4"⟩
"%5" ←ₐ Inv⟨"%1"⟩
⟨"data"⟩[1] ←ᵢ ⟨"%5"⟩
"%2" ←ₐ .Get ⟨"data"⟩ 0 0
guard ⟨"%2"⟩ then (?₀ ⟨"%1"⟩)
"%0" ←ₐ .Const 1
"%3" ←ₐ .Sub ⟨"%0"⟩ ⟨"%2"⟩
guard ⟨"%3"⟩ then ("%4" ←ₐ .Get ⟨"data"⟩ 0 1; "%5" ←ₐ .Mul ⟨"%1"⟩ ⟨"%4"⟩; "%6" ←ₐ .Sub ⟨"%5"⟩ ⟨"%0"⟩; ?₀ ⟨"%6"⟩)
moved "%0" ←ₐ .Const 1 5
Proved optimised_behaviour1
moved "%2" ←ₐ .Get ⟨"in"⟩ 0 0 1
Proved optimised_behaviour2
moved "%3" ←ₐ .Get ⟨"data"⟩ 0 0 2
Proved optimised_behaviour3
moved "%7" ←ₐ .Get ⟨"data"⟩ 0 1 0
Reordered constraints code:
"%1" ←ₐ ⊤
"%2" ←ₐ .Get ⟨"in"⟩ 0 0
"%4" ←ₐ ⟨"%1"⟩ &₀ ⟨"%2"⟩
"%3" ←ₐ .Get ⟨"data"⟩ 0 0
"%5" ←ₐ guard ⟨"%3"⟩ & ⟨"%1"⟩ with ⟨"%4"⟩
"%0" ←ₐ .Const 1
"%6" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
"%7" ←ₐ .Get ⟨"data"⟩ 0 1
"%8" ←ₐ .Mul ⟨"%2"⟩ ⟨"%7"⟩
"%9" ←ₐ .Sub ⟨"%8"⟩ ⟨"%0"⟩
"%10" ←ₐ ⟨"%1"⟩ &₀ ⟨"%9"⟩
"%11" ←ₐ guard ⟨"%6"⟩ & ⟨"%5"⟩ with ⟨"%10"⟩
DUP %4
DUP %5
Drop %1 at line 10. Part2
Drop %4 at line 10. Part2
Drop %5 at line 10. Part2
Drop %2 at line 9. Part2
Drop %0 at line 10. Part2
Drop %3 at line 10. Part2
Drop %6 at line 10. Part2
[
  [],
  [],
  [
    DropFelt { val: '%1', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%4', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%5', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%2', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%0', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%3', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%6', nondet: false, kind: 'dropFelt' }
  ]
]
3
---1---
curr: 0 next: ⟨"data"⟩[1] ←ᵢ ⟨"%5"⟩
%5
Moving drop past set requires 1 hypotheses
curr: 1 next: "%2" ←ₐ .Get ⟨"data"⟩ 0 0
%2
Moving drop past assign/get requires 1 hypotheses
curr: 2 next: guard ⟨"%2"⟩ then (?₀ ⟨"%1"⟩)
%1
Moving drop past eqz requires 1 hypotheses
curr: 3 next: "%0" ←ₐ .Const 1
%0
Moving drop past assign/const requires 1 hypotheses
---2---
curr: 0 next: "%3" ←ₐ .Sub ⟨"%0"⟩ ⟨"%2"⟩
%3
%0
%2
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: guard ⟨"%3"⟩ then ("%4" ←ₐ .Get ⟨"data"⟩ 0 1; "%5" ←ₐ .Mul ⟨"%1"⟩ ⟨"%4"⟩; "%6" ←ₐ .Sub ⟨"%5"⟩ ⟨"%0"⟩; ?₀ ⟨"%6"⟩)
%6
Moving drop past eqz requires 1 hypotheses
%6
%5
%0
Moving drop past assign/binop requires 3 hypotheses
%5
%1
%4
Moving drop past assign/binop requires 3 hypotheses
%4
Moving drop past assign/get requires 1 hypotheses
Drop %2 at line 9. Part2
Drop %3 at line 7. Part1
Drop %0 at line 10. Part2
Drop %6 at line 12. Part2
Drop %7 at line 9. Part2
Drop %8 at line 10. Part2
Drop %9 at line 11. Part2
[
  [],
  [ DropFelt { val: '%3', nondet: false, kind: 'dropFelt' } ],
  [
    DropFelt { val: '%2', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%0', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%6', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%7', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%8', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%9', nondet: false, kind: 'dropFelt' }
  ]
]
3
---1---
curr: 0 next: "%5" ←ₐ guard ⟨"%3"⟩ & ⟨"%1"⟩ with ⟨"%4"⟩
%3
Moving drop past assign/andCond requires 1 hypotheses
curr: 1 next: "%0" ←ₐ .Const 1
%0
Moving drop past assign/const requires 1 hypotheses
curr: 2 next: "%6" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
%6
%0
%3
Moving drop past assign/binop requires 3 hypotheses
curr: 3 next: "%7" ←ₐ .Get ⟨"data"⟩ 0 1
%7
Moving drop past assign/get requires 1 hypotheses
---2---
curr: 0 next: "%8" ←ₐ .Mul ⟨"%2"⟩ ⟨"%7"⟩
%8
%2
%7
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: "%9" ←ₐ .Sub ⟨"%8"⟩ ⟨"%0"⟩
%9
%8
%0
Moving drop past assign/binop requires 3 hypotheses
curr: 2 next: "%10" ←ₐ ⟨"%1"⟩ &₀ ⟨"%9"⟩
%9
Moving drop past assign/andEqz requires 1 hypotheses
curr: 3 next: "%11" ←ₐ guard ⟨"%6"⟩ & ⟨"%5"⟩ with ⟨"%10"⟩
%6
Moving drop past assign/andCond requires 1 hypotheses
✔ [1927/1938] Built Risc0.Gadgets.IsZero.Constraints.CodeReordered
✔ [1929/1938] Built Risc0.Gadgets.IsZero.Constraints.CodeParts
✔ [1931/1938] Built Risc0.Gadgets.IsZero.Constraints.CodeDrops
✔ [1933/1938] Built Risc0
✔ [1934/1938] Built Risc0:c.o
✔ [1935/1938] Built Main
✔ [1937/1938] Built Risc0.MlirTactics:c.o
✔ [1938/1938] Built risc0
Build completed successfully.
---stdout---:


✔ [1927/1938] Built Risc0.Gadgets.IsZero.Constraints.CodeReordered
✔ [1929/1938] Built Risc0.Gadgets.IsZero.Constraints.CodeParts
✔ [1931/1938] Built Risc0.Gadgets.IsZero.Constraints.CodeDrops
✔ [1933/1938] Built Risc0
✔ [1934/1938] Built Risc0:c.o
✔ [1935/1938] Built Main
✔ [1937/1938] Built Risc0.MlirTactics:c.o
✔ [1938/1938] Built risc0
Build completed successfully.

[]
Creating constraints weakest pre files
  0 - sorry
✖ [1934/1940] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part1;
      dropfelt { name := "%3" : FeltVar };
        Code.part2;
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%6" : FeltVar };
                dropfelt { name := "%7" : FeltVar };
                  dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[props][{ name := "%4" : PropVar }] ←
            ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).props
                  { name := "%1" : PropVar }).get! ∧
              (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                    { name := "%2" : FeltVar }).get! =
                (0 : Felt)))["%3"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart0
RECEIVED(constraints)-------------
✖ [1934/1940] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part1;
      dropfelt { name := "%3" : FeltVar };
        Code.part2;
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%6" : FeltVar };
                dropfelt { name := "%7" : FeltVar };
                  dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[props][{ name := "%4" : PropVar }] ←
            ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).props
                  { name := "%1" : PropVar }).get! ∧
              (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                    { name := "%2" : FeltVar }).get! =
                (0 : Felt)))["%3"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart0

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part1;
      dropfelt { name := "%3" : FeltVar };
        Code.part2;
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%6" : FeltVar };
                dropfelt { name := "%7" : FeltVar };
                  dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[props][{ name := "%4" : PropVar }] ←
            ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).props
                  { name := "%1" : PropVar }).get! ∧
              (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                    { name := "%2" : FeltVar }).get! =
                (0 : Felt)))["%3"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart0





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[props][{ name := "%4" : PropVar }] ←
            ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).props
                  { name := "%1" : PropVar }).get! ∧
              (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                    { name := "%2" : FeltVar }).get! =
                (0 : Felt)))["%3"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }) 
State transformer: "
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[props][{ name := "%4" : PropVar }] ←
            ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).props
                  { name := "%1" : PropVar }).get! ∧
              (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                    { name := "%2" : FeltVar }).get! =
                (0 : Felt)))["%3"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) "
Cumulative transformer: "Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }) "
  0 - corrected
Part 1 of 3
  1 - sorry
✖ [1936/1942] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%3" : FeltVar };
      Code.part2;
        dropfelt { name := "%2" : FeltVar };
          dropfelt { name := "%0" : FeltVar };
            dropfelt { name := "%6" : FeltVar };
              dropfelt { name := "%7" : FeltVar };
                dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  if (st.felts { name := "%3" : FeltVar }).get! = (0 : Felt) then True
                  else (st.props { name := "%4" : PropVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - (st.felts { name := "%3" : FeltVar }).get!)["%7"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part1_state_update
        (((({
                  buffers :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                        [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                      [[some in0]],
                  bufferWidths :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                  cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                  vars :=
                    [{ name := "in" : BufferVar },
                      { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                True)[felts][{ name := "%2" : FeltVar }] ←
              in0)[props][{ name := "%4" : PropVar }] ←
            in0 = (0 : Felt))[felts][{ name := "%3" : FeltVar }] ←
          data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart1
RECEIVED(constraints)-------------
✖ [1936/1942] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%3" : FeltVar };
      Code.part2;
        dropfelt { name := "%2" : FeltVar };
          dropfelt { name := "%0" : FeltVar };
            dropfelt { name := "%6" : FeltVar };
              dropfelt { name := "%7" : FeltVar };
                dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  if (st.felts { name := "%3" : FeltVar }).get! = (0 : Felt) then True
                  else (st.props { name := "%4" : PropVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - (st.felts { name := "%3" : FeltVar }).get!)["%7"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part1_state_update
        (((({
                  buffers :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                        [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                      [[some in0]],
                  bufferWidths :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                  cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                  vars :=
                    [{ name := "in" : BufferVar },
                      { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                True)[felts][{ name := "%2" : FeltVar }] ←
              in0)[props][{ name := "%4" : PropVar }] ←
            in0 = (0 : Felt))[felts][{ name := "%3" : FeltVar }] ←
          data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart1

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%3" : FeltVar };
      Code.part2;
        dropfelt { name := "%2" : FeltVar };
          dropfelt { name := "%0" : FeltVar };
            dropfelt { name := "%6" : FeltVar };
              dropfelt { name := "%7" : FeltVar };
                dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  if (st.felts { name := "%3" : FeltVar }).get! = (0 : Felt) then True
                  else (st.props { name := "%4" : PropVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - (st.felts { name := "%3" : FeltVar }).get!)["%7"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part1_state_update
        (((({
                  buffers :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                        [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                      [[some in0]],
                  bufferWidths :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                  cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                  vars :=
                    [{ name := "in" : BufferVar },
                      { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                True)[felts][{ name := "%2" : FeltVar }] ←
              in0)[props][{ name := "%4" : PropVar }] ←
            in0 = (0 : Felt))[felts][{ name := "%3" : FeltVar }] ←
          data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart1





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  if (st.felts { name := "%3" : FeltVar }).get! = (0 : Felt) then True
                  else (st.props { name := "%4" : PropVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - (st.felts { name := "%3" : FeltVar }).get!)["%7"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part1_state_update
        (((({
                  buffers :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                        [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                      [[some in0]],
                  bufferWidths :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                  cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                  vars :=
                    [{ name := "in" : BufferVar },
                      { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                True)[felts][{ name := "%2" : FeltVar }] ←
              in0)[props][{ name := "%4" : PropVar }] ←
            in0 = (0 : Felt))[felts][{ name := "%3" : FeltVar }] ←
          data0)) 
State transformer: "
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  if (st.felts { name := "%3" : FeltVar }).get! = (0 : Felt) then True
                  else (st.props { name := "%4" : PropVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - (st.felts { name := "%3" : FeltVar }).get!)["%7"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) "
Cumulative transformer: "Code.getReturn
      (part1_state_update
        (((({
                  buffers :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                        [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                      [[some in0]],
                  bufferWidths :=
                    (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                  cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                  vars :=
                    [{ name := "in" : BufferVar },
                      { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                True)[felts][{ name := "%2" : FeltVar }] ←
              in0)[props][{ name := "%4" : PropVar }] ←
            in0 = (0 : Felt))[felts][{ name := "%3" : FeltVar }] ←
          data0)) "
  1 - corrected
✔ [1936/1942] Built Risc0.Gadgets.IsZero.Constraints.WeakestPresPart1
✔ [1938/1942] Built Risc0
✔ [1939/1942] Built Risc0:c.o
✔ [1940/1942] Built Main
✔ [1942/1942] Built risc0
Build completed successfully.
  2 - sorry
✖ [1938/1944] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%0" : FeltVar };
        dropfelt { name := "%6" : FeltVar };
          dropfelt { name := "%7" : FeltVar };
            dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%2" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
            ((st.props { name := "%1" : PropVar }).get! ∧
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                  (st.felts { name := "%0" : FeltVar }).get! =
                (0 : Felt)))[props][{ name := "%11" : PropVar }] ←
          (((((st[felts][{ name := "%8" : FeltVar }] ←
                        (st.felts { name := "%2" : FeltVar }).get! *
                          (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                        (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
                    ((st.props { name := "%1" : PropVar }).get! ∧
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                          (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt))).props
                { name := "%5" : PropVar }).get! ∧
            if (st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) then True
            else
              (st.props { name := "%1" : PropVar }).get! ∧
                (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part2_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                            [[some in0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "in" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%2" : FeltVar }] ←
                    in0)[props][{ name := "%4" : PropVar }] ←
                  in0 = (0 : Felt))[props][{ name := "%5" : PropVar }] ←
                (¬data0 = (0 : Felt) → in0 = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - data0)[felts][{ name := "%7" : FeltVar }] ←
          data1)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
RECEIVED(constraints)-------------
✖ [1938/1944] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%0" : FeltVar };
        dropfelt { name := "%6" : FeltVar };
          dropfelt { name := "%7" : FeltVar };
            dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%2" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
            ((st.props { name := "%1" : PropVar }).get! ∧
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                  (st.felts { name := "%0" : FeltVar }).get! =
                (0 : Felt)))[props][{ name := "%11" : PropVar }] ←
          (((((st[felts][{ name := "%8" : FeltVar }] ←
                        (st.felts { name := "%2" : FeltVar }).get! *
                          (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                        (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
                    ((st.props { name := "%1" : PropVar }).get! ∧
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                          (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt))).props
                { name := "%5" : PropVar }).get! ∧
            if (st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) then True
            else
              (st.props { name := "%1" : PropVar }).get! ∧
                (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part2_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                            [[some in0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "in" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%2" : FeltVar }] ←
                    in0)[props][{ name := "%4" : PropVar }] ←
                  in0 = (0 : Felt))[props][{ name := "%5" : PropVar }] ←
                (¬data0 = (0 : Felt) → in0 = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - data0)[felts][{ name := "%7" : FeltVar }] ←
          data1)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%0" : FeltVar };
        dropfelt { name := "%6" : FeltVar };
          dropfelt { name := "%7" : FeltVar };
            dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%9" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%2" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
            ((st.props { name := "%1" : PropVar }).get! ∧
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                  (st.felts { name := "%0" : FeltVar }).get! =
                (0 : Felt)))[props][{ name := "%11" : PropVar }] ←
          (((((st[felts][{ name := "%8" : FeltVar }] ←
                        (st.felts { name := "%2" : FeltVar }).get! *
                          (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                        (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
                    ((st.props { name := "%1" : PropVar }).get! ∧
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                          (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt))).props
                { name := "%5" : PropVar }).get! ∧
            if (st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) then True
            else
              (st.props { name := "%1" : PropVar }).get! ∧
                (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 data0 data1 : Felt
⊢ Code.getReturn
      (part2_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                            [[some in0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "in" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%2" : FeltVar }] ←
                    in0)[props][{ name := "%4" : PropVar }] ←
                  in0 = (0 : Felt))[props][{ name := "%5" : PropVar }] ←
                (¬data0 = (0 : Felt) → in0 = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - data0)[felts][{ name := "%7" : FeltVar }] ←
          data1)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2





STATE TRANSFORMER--
--
--

        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%2" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
            ((st.props { name := "%1" : PropVar }).get! ∧
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                  (st.felts { name := "%0" : FeltVar }).get! =
                (0 : Felt)))[props][{ name := "%11" : PropVar }] ←
          (((((st[felts][{ name := "%8" : FeltVar }] ←
                        (st.felts { name := "%2" : FeltVar }).get! *
                          (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                        (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
                    ((st.props { name := "%1" : PropVar }).get! ∧
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                          (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt))).props
                { name := "%5" : PropVar }).get! ∧
            if (st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) then True
            else
              (st.props { name := "%1" : PropVar }).get! ∧
                (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt))) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part2_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                            [[some in0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "in" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%2" : FeltVar }] ←
                    in0)[props][{ name := "%4" : PropVar }] ←
                  in0 = (0 : Felt))[props][{ name := "%5" : PropVar }] ←
                (¬data0 = (0 : Felt) → in0 = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - data0)[felts][{ name := "%7" : FeltVar }] ←
          data1)) 
State transformer: "
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%2" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
            ((st.props { name := "%1" : PropVar }).get! ∧
              (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                  (st.felts { name := "%0" : FeltVar }).get! =
                (0 : Felt)))[props][{ name := "%11" : PropVar }] ←
          (((((st[felts][{ name := "%8" : FeltVar }] ←
                        (st.felts { name := "%2" : FeltVar }).get! *
                          (st.felts { name := "%7" : FeltVar }).get!)[felts][{ name := "%9" : FeltVar }] ←
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                        (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%10" : PropVar }] ←
                    ((st.props { name := "%1" : PropVar }).get! ∧
                      (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                          (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt))).props
                { name := "%5" : PropVar }).get! ∧
            if (st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) then True
            else
              (st.props { name := "%1" : PropVar }).get! ∧
                (st.felts { name := "%2" : FeltVar }).get! * (st.felts { name := "%7" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt))) "
Cumulative transformer: "Code.getReturn
      (part2_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "in" : BufferVar }] ←ₘ
                            [[some in0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "in" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%2" : FeltVar }] ←
                    in0)[props][{ name := "%4" : PropVar }] ←
                  in0 = (0 : Felt))[props][{ name := "%5" : PropVar }] ←
                (¬data0 = (0 : Felt) → in0 = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            (1 : Felt) - data0)[felts][{ name := "%7" : FeltVar }] ←
          data1)) "
  2 - corrected
✖ [1938/1944] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:109:11: unsolved goals
in0 data0 data1 : Felt
⊢ (¬data0 = (0 : Felt) → in0 = (0 : Felt)) ∧
      (¬(1 : Felt) - data0 = (0 : Felt) → in0 * data1 - (1 : Felt) = (0 : Felt)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
closed form:



 ✖ [1938/1944] Building Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Constraints/WeakestPresPart2.lean:109:11: unsolved goals
in0 data0 data1 : Felt
⊢ (¬data0 = (0 : Felt) → in0 = (0 : Felt)) ∧
      (¬(1 : Felt) - data0 = (0 : Felt) → in0 * data1 - (1 : Felt) = (0 : Felt)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2


 end closed form
 (¬data0 = (0 : Felt) → in0 = (0 : Felt)) ∧
      (¬(1 : Felt) - data0 = (0 : Felt) → in0 * data1 - (1 : Felt) = (0 : Felt)) 
  closed form
✔ [1938/1944] Built Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
✔ [1940/1944] Built Risc0
✔ [1941/1944] Built Risc0:c.o
✔ [1942/1944] Built Main
✔ [1944/1944] Built risc0
Build completed successfully.
Creating witness weakest pre files
  0 - sorry
---stdout---:


✔ [1938/1944] Built Risc0.Gadgets.IsZero.Constraints.WeakestPresPart2
✔ [1940/1944] Built Risc0
✔ [1941/1944] Built Risc0:c.o
✔ [1942/1944] Built Main
✔ [1944/1944] Built risc0
Build completed successfully.

Done
✖ [1940/1946] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:24:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part1;
      Code.part2;
        dropfelt { name := "%1" : FeltVar };
          dropfelt { name := "%4" : FeltVar };
            dropfelt { name := "%5" : FeltVar };
              dropfelt { name := "%2" : FeltVar };
                dropfelt { name := "%0" : FeltVar };
                  dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
                if
                    ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%1" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%1" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%5" : FeltVar }] ←
          if
              (st["%1"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get! =
                (0 : Felt) then
            (0 : Felt)
          else
            (st["%1"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get!⁻¹) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part0_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] })
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart0
RECEIVED(witness)-------------
✖ [1940/1946] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:24:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part1;
      Code.part2;
        dropfelt { name := "%1" : FeltVar };
          dropfelt { name := "%4" : FeltVar };
            dropfelt { name := "%5" : FeltVar };
              dropfelt { name := "%2" : FeltVar };
                dropfelt { name := "%0" : FeltVar };
                  dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
                if
                    ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%1" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%1" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%5" : FeltVar }] ←
          if
              (st["%1"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get! =
                (0 : Felt) then
            (0 : Felt)
          else
            (st["%1"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get!⁻¹) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part0_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] })
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart0

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:24:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part1;
      Code.part2;
        dropfelt { name := "%1" : FeltVar };
          dropfelt { name := "%4" : FeltVar };
            dropfelt { name := "%5" : FeltVar };
              dropfelt { name := "%2" : FeltVar };
                dropfelt { name := "%0" : FeltVar };
                  dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
                if
                    ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%1" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%1" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%5" : FeltVar }] ←
          if
              (st["%1"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get! =
                (0 : Felt) then
            (0 : Felt)
          else
            (st["%1"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get!⁻¹) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part0_state_update st) [data0, data1]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] })
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart0

State transformer: "
        ((((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
                if
                    ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%1" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%1"] ←ₛ getImpl st { name := "in" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%1" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%5" : FeltVar }] ←
          if
              (st["%1"] ←ₛ
                        getImpl st { name := "in" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get! =
                (0 : Felt) then
            (0 : Felt)
          else
            (st["%1"] ←ₛ
                      getImpl st { name := "in" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }].get!⁻¹) "
Cumulative transformer: "Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "in" : BufferVar }, [[some in0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "in" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] })
      ([data0, data1]) "
  0 - corrected
Part 1 of 3
  1 - sorry
✖ [1942/1948] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part2;
      dropfelt { name := "%1" : FeltVar };
        dropfelt { name := "%4" : FeltVar };
          dropfelt { name := "%5" : FeltVar };
            dropfelt { name := "%2" : FeltVar };
              dropfelt { name := "%0" : FeltVar };
                dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((if
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%2" : FeltVar }]!.get! =
                (0 : Felt) then
            (st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
              getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)
          else
            withEqZero
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                      getImpl st { name := "data" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }]!.get!
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part1_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars :=
              [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%5" : FeltVar }] ←
          if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart1
RECEIVED(witness)-------------
✖ [1942/1948] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part2;
      dropfelt { name := "%1" : FeltVar };
        dropfelt { name := "%4" : FeltVar };
          dropfelt { name := "%5" : FeltVar };
            dropfelt { name := "%2" : FeltVar };
              dropfelt { name := "%0" : FeltVar };
                dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((if
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%2" : FeltVar }]!.get! =
                (0 : Felt) then
            (st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
              getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)
          else
            withEqZero
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                      getImpl st { name := "data" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }]!.get!
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part1_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars :=
              [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%5" : FeltVar }] ←
          if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart1

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (Code.part2;
      dropfelt { name := "%1" : FeltVar };
        dropfelt { name := "%4" : FeltVar };
          dropfelt { name := "%5" : FeltVar };
            dropfelt { name := "%2" : FeltVar };
              dropfelt { name := "%0" : FeltVar };
                dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((if
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%2" : FeltVar }]!.get! =
                (0 : Felt) then
            (st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
              getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)
          else
            withEqZero
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                      getImpl st { name := "data" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }]!.get!
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part1_state_update st) [data0, data1]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars :=
              [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%5" : FeltVar }] ←
          if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart1

State transformer: "
        ((if
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back)
                          (0 : ℕ)).felts[{ name := "%2" : FeltVar }]!.get! =
                (0 : Felt) then
            (st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
              getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)
          else
            withEqZero
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                      getImpl st { name := "data" : BufferVar } (0 : Back)
                        (0 : ℕ)).felts[{ name := "%1" : FeltVar }]!.get!
              ((st.set! { name := "data" : BufferVar } (1 : ℕ) st.felts[{ name := "%5" : FeltVar }]!.get!)["%2"] ←ₛ
                getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) "
Cumulative transformer: "Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars :=
              [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%5" : FeltVar }] ←
          if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹))
      ([data0, data1]) "
  1 - corrected
✔ [1944/1948] Built Risc0
✔ [1945/1948] Built Risc0:c.o
✔ [1946/1948] Built Main
✔ [1948/1948] Built risc0
Build completed successfully.
  2 - sorry
✖ [1944/1950] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%1" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        dropfelt { name := "%5" : FeltVar };
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (if (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get! = (0 : Felt) then
          st[felts][{ name := "%3" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!
        else
          withEqZero
            ((st.felts { name := "%1" : FeltVar }).get! *
                (((st[felts][{ name := "%3" : FeltVar }] ←
                          (st.felts { name := "%0" : FeltVar }).get! -
                            (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                    { name := "%4" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)
            ((((st[felts][{ name := "%3" : FeltVar }] ←
                    (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                  getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part2_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part2_state_update
        ((if in0 = (0 : Felt) then
            {
              buffers :=
                (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)[{ name := "%2" : FeltVar }] ←ₘ
                  if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := ¬in0 = (0 : Felt), props := Map.empty,
              vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }
          else
            {
                buffers :=
                  (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ),
                felts :=
                  ((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹,
                isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%2" : FeltVar }] ←
              if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
RECEIVED(witness)-------------
✖ [1944/1950] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%1" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        dropfelt { name := "%5" : FeltVar };
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (if (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get! = (0 : Felt) then
          st[felts][{ name := "%3" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!
        else
          withEqZero
            ((st.felts { name := "%1" : FeltVar }).get! *
                (((st[felts][{ name := "%3" : FeltVar }] ←
                          (st.felts { name := "%0" : FeltVar }).get! -
                            (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                    { name := "%4" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)
            ((((st[felts][{ name := "%3" : FeltVar }] ←
                    (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                  getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part2_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part2_state_update
        ((if in0 = (0 : Felt) then
            {
              buffers :=
                (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)[{ name := "%2" : FeltVar }] ←ₘ
                  if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := ¬in0 = (0 : Felt), props := Map.empty,
              vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }
          else
            {
                buffers :=
                  (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ),
                felts :=
                  ((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹,
                isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%2" : FeltVar }] ←
              if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart2

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%1" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        dropfelt { name := "%5" : FeltVar };
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%3" : FeltVar }; dropfelt { name := "%6" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (if (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get! = (0 : Felt) then
          st[felts][{ name := "%3" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!
        else
          withEqZero
            ((st.felts { name := "%1" : FeltVar }).get! *
                (((st[felts][{ name := "%3" : FeltVar }] ←
                          (st.felts { name := "%0" : FeltVar }).get! -
                            (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                    { name := "%4" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)
            ((((st[felts][{ name := "%3" : FeltVar }] ←
                    (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                  getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part2_state_update st) [data0, data1]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
in0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part2_state_update
        ((if in0 = (0 : Felt) then
            {
              buffers :=
                (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)[{ name := "%2" : FeltVar }] ←ₘ
                  if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := ¬in0 = (0 : Felt), props := Map.empty,
              vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }
          else
            {
                buffers :=
                  (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ),
                felts :=
                  ((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹,
                isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%2" : FeltVar }] ←
              if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart2

State transformer: "
        (if (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get! = (0 : Felt) then
          st[felts][{ name := "%3" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!
        else
          withEqZero
            ((st.felts { name := "%1" : FeltVar }).get! *
                (((st[felts][{ name := "%3" : FeltVar }] ←
                          (st.felts { name := "%0" : FeltVar }).get! -
                            (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                        getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                    { name := "%4" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)
            ((((st[felts][{ name := "%3" : FeltVar }] ←
                    (st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                  getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%1" : FeltVar }).get! *
                  (((st[felts][{ name := "%3" : FeltVar }] ←
                            (st.felts { name := "%0" : FeltVar }).get! -
                              (st.felts { name := "%2" : FeltVar }).get!)["%4"] ←ₛ
                          getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                      { name := "%4" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get!)) "
Cumulative transformer: "Code.getReturn
      (part2_state_update
        ((if in0 = (0 : Felt) then
            {
              buffers :=
                (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)[{ name := "%2" : FeltVar }] ←ₘ
                  if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := ¬in0 = (0 : Felt), props := Map.empty,
              vars := [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }
          else
            {
                buffers :=
                  (Map.empty[{ name := "in" : BufferVar }] ←ₘ [[some in0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹)]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "in" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ),
                felts :=
                  ((Map.empty[{ name := "%1" : FeltVar }] ←ₘ in0)[{ name := "%4" : FeltVar }] ←ₘ
                      if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[{ name := "%5" : FeltVar }] ←ₘ
                    if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹,
                isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "in" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%2" : FeltVar }] ←
              if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      ([data0, data1]) "
  2 - corrected
✖ [1944/1950] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:129:11: unsolved goals
data0 data1 : Option Felt
in0 : Felt
⊢ (some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = data0 ∧
        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹) = data1) ∧
      (¬((1 : Felt) - if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt) →
        (if in0 = (0 : Felt) then (0 : Felt) else in0 * in0⁻¹) - (1 : Felt) = (0 : Felt)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
closed form:



 ✖ [1944/1950] Building Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/IsZero/Witness/WeakestPresPart2.lean:129:11: unsolved goals
data0 data1 : Option Felt
in0 : Felt
⊢ (some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = data0 ∧
        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹) = data1) ∧
      (¬((1 : Felt) - if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt) →
        (if in0 = (0 : Felt) then (0 : Felt) else in0 * in0⁻¹) - (1 : Felt) = (0 : Felt)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.IsZero.Witness.WeakestPresPart2


 end closed form
 (some (if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = data0 ∧
        some (if in0 = (0 : Felt) then (0 : Felt) else in0⁻¹) = data1) ∧
      (¬((1 : Felt) - if in0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt) →
        (if in0 = (0 : Felt) then (0 : Felt) else in0 * in0⁻¹) - (1 : Felt) = (0 : Felt)) 
  closed form
✔ [1944/1950] Built Risc0.Gadgets.IsZero.Witness.WeakestPresPart2
✔ [1945/1950] Built Risc0.Gadgets.IsZero.Witness.WeakestPresPart2:c.o
✔ [1946/1950] Built Risc0
✔ [1947/1950] Built Risc0:c.o
✔ [1948/1950] Built Main
✔ [1950/1950] Built risc0
Build completed successfully.
Build completed successfully.
---stdout---:


Build completed successfully.

----------
----------



Creating code files  
moved "%0" ←ₐ .Const 1 7
Proved optimised_behaviour1
moved "%1" ←ₐ .Const 0 3
Proved optimised_behaviour2
moved "%2" ←ₐ .Get ⟨"code"⟩ 0 0 0
moved "%4" ←ₐ .Get ⟨"data"⟩ 0 0 1
Proved optimised_behaviour3
Reordered witness code:
"%2" ←ₐ .Get ⟨"code"⟩ 0 0
"%8" ←ₐ ??₀⟨"%2"⟩
⟨"data"⟩[0] ←ᵢ ⟨"%8"⟩
"%1" ←ₐ .Const 0
"%3" ←ₐ .Sub ⟨"%1"⟩ ⟨"%2"⟩
?₀ ⟨"%3"⟩
"%0" ←ₐ .Const 1
"%4" ←ₐ .Get ⟨"data"⟩ 0 0
"%5" ←ₐ .Sub ⟨"%0"⟩ ⟨"%4"⟩
"%6" ←ₐ .Mul ⟨"%4"⟩ ⟨"%5"⟩
?₀ ⟨"%6"⟩
"%7" ←ₐ .Sub ⟨"%4"⟩ ⟨"%0"⟩
?₀ ⟨"%7"⟩
moved "%0" ←ₐ .Const 0 3
Proved optimised_behaviour1
moved "%1" ←ₐ .Const 1 6
Proved optimised_behaviour2
moved "%3" ←ₐ .Get ⟨"code"⟩ 0 0 1
Proved optimised_behaviour3
moved "%6" ←ₐ .Get ⟨"data"⟩ 0 0 1
Proved optimised_behaviour4
Reordered constraints code:
"%2" ←ₐ ⊤
"%0" ←ₐ .Const 0
"%3" ←ₐ .Get ⟨"code"⟩ 0 0
"%4" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
"%5" ←ₐ ⟨"%2"⟩ &₀ ⟨"%4"⟩
"%1" ←ₐ .Const 1
"%6" ←ₐ .Get ⟨"data"⟩ 0 0
"%7" ←ₐ .Sub ⟨"%1"⟩ ⟨"%6"⟩
"%8" ←ₐ .Mul ⟨"%6"⟩ ⟨"%7"⟩
"%9" ←ₐ ⟨"%5"⟩ &₀ ⟨"%8"⟩
"%10" ←ₐ .Sub ⟨"%6"⟩ ⟨"%1"⟩
"%11" ←ₐ ⟨"%9"⟩ &₀ ⟨"%10"⟩
Drop %2 at line 5. Part1
Drop %8 at line 3. Part0
Drop %1 at line 5. Part1
Drop %3 at line 6. Part1
Drop %0 at line 12. Part2
Drop %4 at line 12. Part2
Drop %5 at line 10. Part2
Drop %6 at line 11. Part2
Drop %7 at line 13. Part3
[
  [ DropFelt { val: '%8', nondet: false, kind: 'dropFelt' } ],
  [
    DropFelt { val: '%2', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%1', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%3', nondet: false, kind: 'dropFelt' }
  ],
  [
    DropFelt { val: '%0', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%4', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%5', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%6', nondet: false, kind: 'dropFelt' }
  ],
  [ DropFelt { val: '%7', nondet: false, kind: 'dropFelt' } ]
]
4
---1---
curr: 0 next: "%3" ←ₐ .Sub ⟨"%1"⟩ ⟨"%2"⟩
%3
%1
%2
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: ?₀ ⟨"%3"⟩
%3
Moving drop past eqz requires 1 hypotheses
curr: 2 next: "%0" ←ₐ .Const 1
%0
Moving drop past assign/const requires 1 hypotheses
curr: 3 next: "%4" ←ₐ .Get ⟨"data"⟩ 0 0
%4
Moving drop past assign/get requires 1 hypotheses
---2---
curr: 0 next: "%5" ←ₐ .Sub ⟨"%0"⟩ ⟨"%4"⟩
%5
%0
%4
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: "%6" ←ₐ .Mul ⟨"%4"⟩ ⟨"%5"⟩
%6
%4
%5
Moving drop past assign/binop requires 3 hypotheses
curr: 2 next: ?₀ ⟨"%6"⟩
%6
Moving drop past eqz requires 1 hypotheses
curr: 3 next: "%7" ←ₐ .Sub ⟨"%4"⟩ ⟨"%0"⟩
%7
%4
%0
Moving drop past assign/binop requires 3 hypotheses
---3---
curr: 0 next: ?₀ ⟨"%7"⟩
%7
Moving drop past eqz requires 1 hypotheses
Drop %0 at line 4. Part0
Drop %3 at line 4. Part0
Drop %4 at line 5. Part1
Drop %1 at line 11. Part2
Drop %6 at line 11. Part2
Drop %7 at line 9. Part2
Drop %8 at line 10. Part2
Drop %10 at line 12. Part2
[
  [
    DropFelt { val: '%0', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%3', nondet: false, kind: 'dropFelt' }
  ],
  [ DropFelt { val: '%4', nondet: false, kind: 'dropFelt' } ],
  [
    DropFelt { val: '%1', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%6', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%7', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%8', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%10', nondet: false, kind: 'dropFelt' }
  ]
]
3
---1---
curr: 0 next: "%5" ←ₐ ⟨"%2"⟩ &₀ ⟨"%4"⟩
%4
Moving drop past assign/andEqz requires 1 hypotheses
curr: 1 next: "%1" ←ₐ .Const 1
%1
Moving drop past assign/const requires 1 hypotheses
curr: 2 next: "%6" ←ₐ .Get ⟨"data"⟩ 0 0
%6
Moving drop past assign/get requires 1 hypotheses
curr: 3 next: "%7" ←ₐ .Sub ⟨"%1"⟩ ⟨"%6"⟩
%7
%1
%6
Moving drop past assign/binop requires 3 hypotheses
---2---
curr: 0 next: "%8" ←ₐ .Mul ⟨"%6"⟩ ⟨"%7"⟩
%8
%6
%7
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: "%9" ←ₐ ⟨"%5"⟩ &₀ ⟨"%8"⟩
%8
Moving drop past assign/andEqz requires 1 hypotheses
curr: 2 next: "%10" ←ₐ .Sub ⟨"%6"⟩ ⟨"%1"⟩
%10
%6
%1
Moving drop past assign/binop requires 3 hypotheses
curr: 3 next: "%11" ←ₐ ⟨"%9"⟩ &₀ ⟨"%10"⟩
%10
Moving drop past assign/andEqz requires 1 hypotheses
✔ [1950/1966] Built Risc0.Gadgets.OneHot1.Constraints.CodeReordered
✔ [1951/1966] Built Risc0.Gadgets.OneHot1.Witness.CodeReordered
✔ [1954/1966] Built Risc0.Gadgets.OneHot1.Witness.CodeParts
✔ [1956/1966] Built Risc0.Gadgets.OneHot1.Constraints.CodeParts
✔ [1958/1966] Built Risc0.Gadgets.OneHot1.Constraints.CodeDrops
✔ [1960/1966] Built Risc0.Gadgets.OneHot1.Witness.CodeDrops
✔ [1962/1966] Built Risc0
✔ [1963/1966] Built Risc0:c.o
✔ [1964/1966] Built Main
✔ [1966/1966] Built risc0
Build completed successfully.
---stdout---:


✔ [1950/1966] Built Risc0.Gadgets.OneHot1.Constraints.CodeReordered
✔ [1951/1966] Built Risc0.Gadgets.OneHot1.Witness.CodeReordered
✔ [1954/1966] Built Risc0.Gadgets.OneHot1.Witness.CodeParts
✔ [1956/1966] Built Risc0.Gadgets.OneHot1.Constraints.CodeParts
✔ [1958/1966] Built Risc0.Gadgets.OneHot1.Constraints.CodeDrops
✔ [1960/1966] Built Risc0.Gadgets.OneHot1.Witness.CodeDrops
✔ [1962/1966] Built Risc0
✔ [1963/1966] Built Risc0:c.o
✔ [1964/1966] Built Main
✔ [1966/1966] Built risc0
Build completed successfully.

[]
Creating constraints weakest pre files
  0 - sorry
✖ [1962/1968] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%0" : FeltVar };
      dropfelt { name := "%3" : FeltVar };
        Code.part1;
          dropfelt { name := "%4" : FeltVar };
            Code.part2;
              dropfelt { name := "%1" : FeltVar };
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%7" : FeltVar };
                    dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
            getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          -((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%3" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[some data0]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart0
RECEIVED(constraints)-------------
✖ [1962/1968] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%0" : FeltVar };
      dropfelt { name := "%3" : FeltVar };
        Code.part1;
          dropfelt { name := "%4" : FeltVar };
            Code.part2;
              dropfelt { name := "%1" : FeltVar };
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%7" : FeltVar };
                    dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
            getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          -((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%3" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[some data0]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart0

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%0" : FeltVar };
      dropfelt { name := "%3" : FeltVar };
        Code.part1;
          dropfelt { name := "%4" : FeltVar };
            Code.part2;
              dropfelt { name := "%1" : FeltVar };
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%7" : FeltVar };
                    dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
            getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          -((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%3" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[some data0]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart0





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
            getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          -((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%3" : FeltVar }).get!) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[some data0]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) 
State transformer: "
        ((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
            getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          -((((st[props][{ name := "%2" : PropVar }] ← True)[felts][{ name := "%0" : FeltVar }] ← (0 : Felt))["%3"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%3" : FeltVar }).get!) "
Cumulative transformer: "Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[some data0]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) "
  0 - corrected
Part 1 of 3
  1 - sorry
✖ [1964/1970] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%4" : FeltVar };
      Code.part2;
        dropfelt { name := "%1" : FeltVar };
          dropfelt { name := "%6" : FeltVar };
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%2" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%2" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part1_state_update
        (({
              buffers :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                  [[some code0]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
            True)[felts][{ name := "%4" : FeltVar }] ←
          -code0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1
RECEIVED(constraints)-------------
✖ [1964/1970] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%4" : FeltVar };
      Code.part2;
        dropfelt { name := "%1" : FeltVar };
          dropfelt { name := "%6" : FeltVar };
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%2" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%2" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part1_state_update
        (({
              buffers :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                  [[some code0]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
            True)[felts][{ name := "%4" : FeltVar }] ←
          -code0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%4" : FeltVar };
      Code.part2;
        dropfelt { name := "%1" : FeltVar };
          dropfelt { name := "%6" : FeltVar };
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%2" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%2" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part1_state_update
        (({
              buffers :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                  [[some code0]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
            True)[felts][{ name := "%4" : FeltVar }] ←
          -code0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%2" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%2" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part1_state_update
        (({
              buffers :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                  [[some code0]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
            True)[felts][{ name := "%4" : FeltVar }] ←
          -code0)) 
State transformer: "
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%2" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%2" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) "
Cumulative transformer: "Code.getReturn
      (part1_state_update
        (({
              buffers :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                  [[some code0]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
            True)[felts][{ name := "%4" : FeltVar }] ←
          -code0)) "
  1 - corrected
✔ [1964/1970] Built Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1
✔ [1965/1970] Built Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart1:c.o
✔ [1966/1970] Built Risc0
✔ [1967/1970] Built Risc0:c.o
✔ [1968/1970] Built Main
✔ [1970/1970] Built risc0
Build completed successfully.
  2 - sorry
✖ [1966/1972] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%1" : FeltVar };
      dropfelt { name := "%6" : FeltVar };
        dropfelt { name := "%7" : FeltVar };
          dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! -
              (st.felts { name := "%1" : FeltVar }).get!)[props][{ name := "%11" : PropVar }] ←
          (((st.props { name := "%5" : PropVar }).get! ∧
              ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))) ∧
            (st.felts { name := "%6" : FeltVar }).get! - (st.felts { name := "%1" : FeltVar }).get! =
              (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part2_state_update
        ((((({
                    buffers :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                        [[some code0]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                    vars :=
                      [{ name := "code" : BufferVar },
                        { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
                  True)[props][{ name := "%5" : PropVar }] ←
                code0 = (0 : Felt))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
RECEIVED(constraints)-------------
✖ [1966/1972] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%1" : FeltVar };
      dropfelt { name := "%6" : FeltVar };
        dropfelt { name := "%7" : FeltVar };
          dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! -
              (st.felts { name := "%1" : FeltVar }).get!)[props][{ name := "%11" : PropVar }] ←
          (((st.props { name := "%5" : PropVar }).get! ∧
              ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))) ∧
            (st.felts { name := "%6" : FeltVar }).get! - (st.felts { name := "%1" : FeltVar }).get! =
              (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part2_state_update
        ((((({
                    buffers :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                        [[some code0]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                    vars :=
                      [{ name := "code" : BufferVar },
                        { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
                  True)[props][{ name := "%5" : PropVar }] ←
                code0 = (0 : Felt))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%1" : FeltVar };
      dropfelt { name := "%6" : FeltVar };
        dropfelt { name := "%7" : FeltVar };
          dropfelt { name := "%8" : FeltVar }; dropfelt { name := "%10" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! -
              (st.felts { name := "%1" : FeltVar }).get!)[props][{ name := "%11" : PropVar }] ←
          (((st.props { name := "%5" : PropVar }).get! ∧
              ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))) ∧
            (st.felts { name := "%6" : FeltVar }).get! - (st.felts { name := "%1" : FeltVar }).get! =
              (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 : Felt
⊢ Code.getReturn
      (part2_state_update
        ((((({
                    buffers :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                        [[some code0]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                    vars :=
                      [{ name := "code" : BufferVar },
                        { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
                  True)[props][{ name := "%5" : PropVar }] ←
                code0 = (0 : Felt))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2





STATE TRANSFORMER--
--
--

        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! -
              (st.felts { name := "%1" : FeltVar }).get!)[props][{ name := "%11" : PropVar }] ←
          (((st.props { name := "%5" : PropVar }).get! ∧
              ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))) ∧
            (st.felts { name := "%6" : FeltVar }).get! - (st.felts { name := "%1" : FeltVar }).get! =
              (0 : Felt))) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part2_state_update
        ((((({
                    buffers :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                        [[some code0]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                    vars :=
                      [{ name := "code" : BufferVar },
                        { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
                  True)[props][{ name := "%5" : PropVar }] ←
                code0 = (0 : Felt))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) 
State transformer: "
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! -
              (st.felts { name := "%1" : FeltVar }).get!)[props][{ name := "%11" : PropVar }] ←
          (((st.props { name := "%5" : PropVar }).get! ∧
              ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))) ∧
            (st.felts { name := "%6" : FeltVar }).get! - (st.felts { name := "%1" : FeltVar }).get! =
              (0 : Felt))) "
Cumulative transformer: "Code.getReturn
      (part2_state_update
        ((((({
                    buffers :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ [[some data0]])[{ name := "code" : BufferVar }] ←ₘ
                        [[some code0]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                    vars :=
                      [{ name := "code" : BufferVar },
                        { name := "data" : BufferVar }] }[props][{ name := "%2" : PropVar }] ←
                  True)[props][{ name := "%5" : PropVar }] ←
                code0 = (0 : Felt))[felts][{ name := "%1" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) "
  2 - corrected
✖ [1966/1972] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:93:11: unsolved goals
code0 data0 : Felt
⊢ (code0 = (0 : Felt) ∧ (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))) ∧ data0 - (1 : Felt) = (0 : Felt) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
closed form:



 ✖ [1966/1972] Building Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot1/Constraints/WeakestPresPart2.lean:93:11: unsolved goals
code0 data0 : Felt
⊢ (code0 = (0 : Felt) ∧ (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))) ∧ data0 - (1 : Felt) = (0 : Felt) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2


 end closed form
 (code0 = (0 : Felt) ∧ (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))) ∧ data0 - (1 : Felt) = (0 : Felt) 
  closed form
✔ [1966/1972] Built Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
✔ [1967/1972] Built Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2:c.o
✔ [1968/1972] Built Risc0
✔ [1969/1972] Built Risc0:c.o
✔ [1970/1972] Built Main
✔ [1972/1972] Built risc0
Build completed successfully.
Creating witness weakest pre files
  0 - sorry
---stdout---:


✔ [1966/1972] Built Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2
✔ [1967/1972] Built Risc0.Gadgets.OneHot1.Constraints.WeakestPresPart2:c.o
✔ [1968/1972] Built Risc0
✔ [1969/1972] Built Risc0:c.o
✔ [1970/1972] Built Main
✔ [1972/1972] Built risc0
Build completed successfully.

Done
✖ [1968/1974] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:24:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%8" : FeltVar };
      Code.part1;
        dropfelt { name := "%2" : FeltVar };
          dropfelt { name := "%1" : FeltVar };
            dropfelt { name := "%3" : FeltVar };
              Code.part2;
                dropfelt { name := "%0" : FeltVar };
                  dropfelt { name := "%4" : FeltVar };
                    dropfelt { name := "%5" : FeltVar };
                      dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%8" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part0_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart0
RECEIVED(witness)-------------
✖ [1968/1974] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:24:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%8" : FeltVar };
      Code.part1;
        dropfelt { name := "%2" : FeltVar };
          dropfelt { name := "%1" : FeltVar };
            dropfelt { name := "%3" : FeltVar };
              Code.part2;
                dropfelt { name := "%0" : FeltVar };
                  dropfelt { name := "%4" : FeltVar };
                    dropfelt { name := "%5" : FeltVar };
                      dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%8" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part0_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart0

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:24:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%8" : FeltVar };
      Code.part1;
        dropfelt { name := "%2" : FeltVar };
          dropfelt { name := "%1" : FeltVar };
            dropfelt { name := "%3" : FeltVar };
              Code.part2;
                dropfelt { name := "%0" : FeltVar };
                  dropfelt { name := "%4" : FeltVar };
                    dropfelt { name := "%5" : FeltVar };
                      dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%8" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part0_state_update st) [data0]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart0

State transformer: "
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%8" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)) "
Cumulative transformer: "Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (1 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      ([data0]) "
  0 - corrected
Part 1 of 4
  1 - sorry
✖ [1970/1976] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%1" : FeltVar };
        dropfelt { name := "%3" : FeltVar };
          Code.part2;
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%4" : FeltVar };
                dropfelt { name := "%5" : FeltVar };
                  dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (((withEqZero ((st.felts { name := "%1" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%3" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! -
                  (st.felts { name := "%2" : FeltVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))["%4"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part1_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1
RECEIVED(witness)-------------
✖ [1970/1976] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%1" : FeltVar };
        dropfelt { name := "%3" : FeltVar };
          Code.part2;
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%4" : FeltVar };
                dropfelt { name := "%5" : FeltVar };
                  dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (((withEqZero ((st.felts { name := "%1" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%3" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! -
                  (st.felts { name := "%2" : FeltVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))["%4"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part1_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%1" : FeltVar };
        dropfelt { name := "%3" : FeltVar };
          Code.part2;
            dropfelt { name := "%0" : FeltVar };
              dropfelt { name := "%4" : FeltVar };
                dropfelt { name := "%5" : FeltVar };
                  dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (((withEqZero ((st.felts { name := "%1" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%3" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! -
                  (st.felts { name := "%2" : FeltVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))["%4"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part1_state_update st) [data0]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1

State transformer: "
        (((withEqZero ((st.felts { name := "%1" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%3" : FeltVar }] ←
                (st.felts { name := "%1" : FeltVar }).get! -
                  (st.felts { name := "%2" : FeltVar }).get!))[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))["%4"] ←ₛ
          getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)) "
Cumulative transformer: "Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%1" : FeltVar }] ←
          (0 : Felt)))
      ([data0]) "
  1 - corrected
✔ [1970/1976] Built Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1
✔ [1971/1976] Built Risc0.Gadgets.OneHot1.Witness.WeakestPresPart1:c.o
✔ [1972/1976] Built Risc0
✔ [1973/1976] Built Risc0:c.o
✔ [1974/1976] Built Main
✔ [1976/1976] Built risc0
Build completed successfully.
Part 2 of 4
  2 - sorry
✖ [1972/1978] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%0" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        dropfelt { name := "%5" : FeltVar };
          dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((withEqZero
            ((st.felts { name := "%4" : FeltVar }).get! *
              ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%4" : FeltVar }).get!))
            ((st[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%4" : FeltVar }).get! *
                ((st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)))[felts][{ name := "%7" : FeltVar }] ←
          (st.felts { name := "%4" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get!) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part2_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part2_state_update
        (({
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := ¬code0 = (0 : Felt), props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))[felts][{ name := "%4" : FeltVar }] ←
          if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2
RECEIVED(witness)-------------
✖ [1972/1978] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%0" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        dropfelt { name := "%5" : FeltVar };
          dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((withEqZero
            ((st.felts { name := "%4" : FeltVar }).get! *
              ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%4" : FeltVar }).get!))
            ((st[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%4" : FeltVar }).get! *
                ((st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)))[felts][{ name := "%7" : FeltVar }] ←
          (st.felts { name := "%4" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get!) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part2_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part2_state_update
        (({
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := ¬code0 = (0 : Felt), props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))[felts][{ name := "%4" : FeltVar }] ←
          if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%0" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        dropfelt { name := "%5" : FeltVar };
          dropfelt { name := "%6" : FeltVar }; Code.part3; dropfelt { name := "%7" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((withEqZero
            ((st.felts { name := "%4" : FeltVar }).get! *
              ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%4" : FeltVar }).get!))
            ((st[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%4" : FeltVar }).get! *
                ((st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)))[felts][{ name := "%7" : FeltVar }] ←
          (st.felts { name := "%4" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get!) ⟦prog⟧)
      [data0] ↔
    Code.getReturn (part2_state_update st) [data0]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart2.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part2_state_update
        (({
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := ¬code0 = (0 : Felt), props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))[felts][{ name := "%4" : FeltVar }] ←
          if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2

State transformer: "
        ((withEqZero
            ((st.felts { name := "%4" : FeltVar }).get! *
              ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%4" : FeltVar }).get!))
            ((st[felts][{ name := "%5" : FeltVar }] ←
                (st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)[felts][{ name := "%6" : FeltVar }] ←
              (st.felts { name := "%4" : FeltVar }).get! *
                ((st.felts { name := "%0" : FeltVar }).get! -
                  (st.felts { name := "%4" : FeltVar }).get!)))[felts][{ name := "%7" : FeltVar }] ←
          (st.felts { name := "%4" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get!) "
Cumulative transformer: "Code.getReturn
      (part2_state_update
        (({
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ), felts := Map.empty, isFailed := ¬code0 = (0 : Felt), props := Map.empty,
              vars :=
                [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
            (1 : Felt))[felts][{ name := "%4" : FeltVar }] ←
          if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)))
      ([data0]) "
  2 - corrected
✔ [1972/1978] Built Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2
✔ [1973/1978] Built Risc0.Gadgets.OneHot1.Witness.WeakestPresPart2:c.o
✔ [1974/1978] Built Risc0
✔ [1975/1978] Built Risc0:c.o
✔ [1976/1978] Built Main
✔ [1978/1978] Built risc0
Build completed successfully.
  3 - sorry
✖ [1974/1980] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq : dropfelt { name := "%7" : FeltVar } = prog
⊢ Code.getReturn (Γ (withEqZero st.felts[{ name := "%7" : FeltVar }]!.get! st) ⟦prog⟧) [data0] ↔
    Code.getReturn (part3_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part3_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty,
            isFailed :=
              ¬code0 = (0 : Felt) ∨
                code0 = (0 : Felt) ∧ ¬((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt),
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%7" : FeltVar }] ←
          (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
RECEIVED(witness)-------------
✖ [1974/1980] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq : dropfelt { name := "%7" : FeltVar } = prog
⊢ Code.getReturn (Γ (withEqZero st.felts[{ name := "%7" : FeltVar }]!.get! st) ⟦prog⟧) [data0] ↔
    Code.getReturn (part3_state_update st) [data0]
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part3_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty,
            isFailed :=
              ¬code0 = (0 : Felt) ∨
                code0 = (0 : Felt) ∧ ¬((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt),
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%7" : FeltVar }] ←
          (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:25:54: unsolved goals
st : State
data0 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq : dropfelt { name := "%7" : FeltVar } = prog
⊢ Code.getReturn (Γ (withEqZero st.felts[{ name := "%7" : FeltVar }]!.get! st) ⟦prog⟧) [data0] ↔
    Code.getReturn (part3_state_update st) [data0]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 : Option Felt
⊢ Code.getReturn
      (part3_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty,
            isFailed :=
              ¬code0 = (0 : Felt) ∨
                code0 = (0 : Felt) ∧ ¬((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt),
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%7" : FeltVar }] ←
          (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt)))
      [data0] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3

State transformer: " (withEqZero st.felts[{ name := "%7" : FeltVar }]!.get! st) "
Cumulative transformer: "Code.getReturn
      (part3_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt))]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (1 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty,
            isFailed :=
              ¬code0 = (0 : Felt) ∨
                code0 = (0 : Felt) ∧ ¬((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt),
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%7" : FeltVar }] ←
          (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt)))
      ([data0]) "
  3 - corrected
✖ [1974/1980] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:81:11: unsolved goals
data0 : Option Felt
code0 : Felt
⊢ some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = data0 ∧
      (code0 = (0 : Felt) ∧
          (code0 = (0 : Felt) → ((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt))) ∧
        (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt) = (0 : Felt) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
closed form:



 ✖ [1974/1980] Building Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot1/Witness/WeakestPresPart3.lean:81:11: unsolved goals
data0 : Option Felt
code0 : Felt
⊢ some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = data0 ∧
      (code0 = (0 : Felt) ∧
          (code0 = (0 : Felt) → ((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt))) ∧
        (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt) = (0 : Felt) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3


 end closed form
 some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = data0 ∧
      (code0 = (0 : Felt) ∧
          (code0 = (0 : Felt) → ((1 : Felt) - if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) = (0 : Felt))) ∧
        (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)) - (1 : Felt) = (0 : Felt) 
  closed form
✔ [1974/1980] Built Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3
✔ [1975/1980] Built Risc0.Gadgets.OneHot1.Witness.WeakestPresPart3:c.o
✔ [1976/1980] Built Risc0
✔ [1977/1980] Built Risc0:c.o
✔ [1978/1980] Built Main
✔ [1980/1980] Built risc0
Build completed successfully.
Build completed successfully.
---stdout---:


Build completed successfully.

----------
----------



Creating code files  
moved "%0" ←ₐ .Const 1 4
Proved optimised_behaviour1
moved "%1" ←ₐ .Const 0 -2
Proved optimised_behaviour2
moved "%2" ←ₐ .Get ⟨"code"⟩ 0 0 0
moved "%3" ←ₐ .Get ⟨"data"⟩ 0 1 0
moved "%5" ←ₐ .Get ⟨"data"⟩ 0 0 0
Reordered witness code:
"%2" ←ₐ .Get ⟨"code"⟩ 0 0
"%12" ←ₐ ??₀⟨"%2"⟩
⟨"data"⟩[0] ←ᵢ ⟨"%12"⟩
"%0" ←ₐ .Const 1
"%13" ←ₐ .Sub ⟨"%2"⟩ ⟨"%0"⟩
"%14" ←ₐ ??₀⟨"%13"⟩
⟨"data"⟩[1] ←ᵢ ⟨"%14"⟩
"%3" ←ₐ .Get ⟨"data"⟩ 0 1
"%4" ←ₐ .Sub ⟨"%3"⟩ ⟨"%2"⟩
?₀ ⟨"%4"⟩
"%5" ←ₐ .Get ⟨"data"⟩ 0 0
"%6" ←ₐ .Sub ⟨"%0"⟩ ⟨"%5"⟩
"%7" ←ₐ .Mul ⟨"%5"⟩ ⟨"%6"⟩
?₀ ⟨"%7"⟩
"%8" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
"%9" ←ₐ .Mul ⟨"%3"⟩ ⟨"%8"⟩
?₀ ⟨"%9"⟩
"%10" ←ₐ .Add ⟨"%5"⟩ ⟨"%3"⟩
"%11" ←ₐ .Sub ⟨"%10"⟩ ⟨"%0"⟩
"%1" ←ₐ .Const 0
?₀ ⟨"%11"⟩
moved "%0" ←ₐ .Const 1 6
Proved optimised_behaviour1
moved "%2" ←ₐ .Get ⟨"code"⟩ 0 0 1
Proved optimised_behaviour2
moved "%3" ←ₐ .Get ⟨"data"⟩ 0 1 1
Proved optimised_behaviour3
moved "%6" ←ₐ .Get ⟨"data"⟩ 0 0 1
Proved optimised_behaviour4
Reordered constraints code:
"%1" ←ₐ ⊤
"%2" ←ₐ .Get ⟨"code"⟩ 0 0
"%3" ←ₐ .Get ⟨"data"⟩ 0 1
"%4" ←ₐ .Sub ⟨"%3"⟩ ⟨"%2"⟩
"%5" ←ₐ ⟨"%1"⟩ &₀ ⟨"%4"⟩
"%0" ←ₐ .Const 1
"%6" ←ₐ .Get ⟨"data"⟩ 0 0
"%7" ←ₐ .Sub ⟨"%0"⟩ ⟨"%6"⟩
"%8" ←ₐ .Mul ⟨"%6"⟩ ⟨"%7"⟩
"%9" ←ₐ ⟨"%5"⟩ &₀ ⟨"%8"⟩
"%10" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
"%11" ←ₐ .Mul ⟨"%3"⟩ ⟨"%10"⟩
"%12" ←ₐ ⟨"%9"⟩ &₀ ⟨"%11"⟩
"%13" ←ₐ .Add ⟨"%6"⟩ ⟨"%3"⟩
"%14" ←ₐ .Sub ⟨"%13"⟩ ⟨"%0"⟩
"%15" ←ₐ ⟨"%12"⟩ &₀ ⟨"%14"⟩
Drop %2 at line 9. Part2
Drop %12 at line 3. Part0
Drop %0 at line 19. Part4
Drop %13 at line 6. Part1
Drop %14 at line 7. Part1
Drop %3 at line 18. Part4
Drop %4 at line 10. Part2
Drop %5 at line 18. Part4
Drop %6 at line 13. Part3
Drop %7 at line 14. Part3
Drop %8 at line 16. Part3
Drop %9 at line 17. Part4
Drop %10 at line 19. Part4
Drop %11 at line 21. Part5
Drop %1 at line 22. Part5
[
  [ DropFelt { val: '%12', nondet: false, kind: 'dropFelt' } ],
  [
    DropFelt { val: '%13', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%14', nondet: false, kind: 'dropFelt' }
  ],
  [
    DropFelt { val: '%2', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%4', nondet: false, kind: 'dropFelt' }
  ],
  [
    DropFelt { val: '%6', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%7', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%8', nondet: false, kind: 'dropFelt' }
  ],
  [
    DropFelt { val: '%0', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%3', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%5', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%9', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%10', nondet: false, kind: 'dropFelt' }
  ],
  [
    DropFelt { val: '%11', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%1', nondet: false, kind: 'dropFelt' }
  ]
]
6
---1---
curr: 0 next: "%13" ←ₐ .Sub ⟨"%2"⟩ ⟨"%0"⟩
%13
%2
%0
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: "%14" ←ₐ ??₀⟨"%13"⟩
%14
%13
Moving drop past assign/isz requires 2 hypotheses
curr: 2 next: ⟨"data"⟩[1] ←ᵢ ⟨"%14"⟩
%14
Moving drop past set requires 1 hypotheses
curr: 3 next: "%3" ←ₐ .Get ⟨"data"⟩ 0 1
%3
Moving drop past assign/get requires 1 hypotheses
---2---
curr: 0 next: "%4" ←ₐ .Sub ⟨"%3"⟩ ⟨"%2"⟩
%4
%3
%2
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: ?₀ ⟨"%4"⟩
%4
Moving drop past eqz requires 1 hypotheses
curr: 2 next: "%5" ←ₐ .Get ⟨"data"⟩ 0 0
%5
Moving drop past assign/get requires 1 hypotheses
curr: 3 next: "%6" ←ₐ .Sub ⟨"%0"⟩ ⟨"%5"⟩
%6
%0
%5
Moving drop past assign/binop requires 3 hypotheses
---3---
curr: 0 next: "%7" ←ₐ .Mul ⟨"%5"⟩ ⟨"%6"⟩
%7
%5
%6
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: ?₀ ⟨"%7"⟩
%7
Moving drop past eqz requires 1 hypotheses
curr: 2 next: "%8" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
%8
%0
%3
Moving drop past assign/binop requires 3 hypotheses
curr: 3 next: "%9" ←ₐ .Mul ⟨"%3"⟩ ⟨"%8"⟩
%9
%3
%8
Moving drop past assign/binop requires 3 hypotheses
---4---
curr: 0 next: ?₀ ⟨"%9"⟩
%9
Moving drop past eqz requires 1 hypotheses
curr: 1 next: "%10" ←ₐ .Add ⟨"%5"⟩ ⟨"%3"⟩
%10
%5
%3
Moving drop past assign/binop requires 3 hypotheses
curr: 2 next: "%11" ←ₐ .Sub ⟨"%10"⟩ ⟨"%0"⟩
%11
%10
%0
Moving drop past assign/binop requires 3 hypotheses
curr: 3 next: "%1" ←ₐ .Const 0
%1
Moving drop past assign/const requires 1 hypotheses
---5---
curr: 0 next: ?₀ ⟨"%11"⟩
%11
Moving drop past eqz requires 1 hypotheses
Drop %2 at line 4. Part0
Drop %3 at line 14. Part3
Drop %4 at line 5. Part1
Drop %0 at line 15. Part3
Drop %6 at line 14. Part3
Drop %7 at line 9. Part2
Drop %8 at line 10. Part2
Drop %10 at line 12. Part2
Drop %11 at line 13. Part3
Drop %13 at line 15. Part3
Drop %14 at line 16. Part3
[
  [ DropFelt { val: '%2', nondet: false, kind: 'dropFelt' } ],
  [ DropFelt { val: '%4', nondet: false, kind: 'dropFelt' } ],
  [
    DropFelt { val: '%7', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%8', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%10', nondet: false, kind: 'dropFelt' }
  ],
  [
    DropFelt { val: '%3', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%0', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%6', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%11', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%13', nondet: false, kind: 'dropFelt' },
    DropFelt { val: '%14', nondet: false, kind: 'dropFelt' }
  ]
]
4
---1---
curr: 0 next: "%5" ←ₐ ⟨"%1"⟩ &₀ ⟨"%4"⟩
%4
Moving drop past assign/andEqz requires 1 hypotheses
curr: 1 next: "%0" ←ₐ .Const 1
%0
Moving drop past assign/const requires 1 hypotheses
curr: 2 next: "%6" ←ₐ .Get ⟨"data"⟩ 0 0
%6
Moving drop past assign/get requires 1 hypotheses
curr: 3 next: "%7" ←ₐ .Sub ⟨"%0"⟩ ⟨"%6"⟩
%7
%0
%6
Moving drop past assign/binop requires 3 hypotheses
---2---
curr: 0 next: "%8" ←ₐ .Mul ⟨"%6"⟩ ⟨"%7"⟩
%8
%6
%7
Moving drop past assign/binop requires 3 hypotheses
curr: 1 next: "%9" ←ₐ ⟨"%5"⟩ &₀ ⟨"%8"⟩
%8
Moving drop past assign/andEqz requires 1 hypotheses
curr: 2 next: "%10" ←ₐ .Sub ⟨"%0"⟩ ⟨"%3"⟩
%10
%0
%3
Moving drop past assign/binop requires 3 hypotheses
curr: 3 next: "%11" ←ₐ .Mul ⟨"%3"⟩ ⟨"%10"⟩
%11
%3
%10
Moving drop past assign/binop requires 3 hypotheses
---3---
curr: 0 next: "%12" ←ₐ ⟨"%9"⟩ &₀ ⟨"%11"⟩
%11
Moving drop past assign/andEqz requires 1 hypotheses
curr: 1 next: "%13" ←ₐ .Add ⟨"%6"⟩ ⟨"%3"⟩
%13
%6
%3
Moving drop past assign/binop requires 3 hypotheses
curr: 2 next: "%14" ←ₐ .Sub ⟨"%13"⟩ ⟨"%0"⟩
%14
%13
%0
Moving drop past assign/binop requires 3 hypotheses
curr: 3 next: "%15" ←ₐ ⟨"%12"⟩ &₀ ⟨"%14"⟩
%14
Moving drop past assign/andEqz requires 1 hypotheses
✔ [1980/1996] Built Risc0.Gadgets.OneHot2.Constraints.CodeReordered
✔ [1981/1996] Built Risc0.Gadgets.OneHot2.Witness.CodeReordered
✔ [1984/1996] Built Risc0.Gadgets.OneHot2.Constraints.CodeParts
✔ [1986/1996] Built Risc0.Gadgets.OneHot2.Witness.CodeParts
✔ [1988/1996] Built Risc0.Gadgets.OneHot2.Constraints.CodeDrops
✔ [1990/1996] Built Risc0.Gadgets.OneHot2.Witness.CodeDrops
✔ [1992/1996] Built Risc0
✔ [1993/1996] Built Risc0:c.o
✔ [1994/1996] Built Main
✔ [1996/1996] Built risc0
Build completed successfully.
---stdout---:


✔ [1980/1996] Built Risc0.Gadgets.OneHot2.Constraints.CodeReordered
✔ [1981/1996] Built Risc0.Gadgets.OneHot2.Witness.CodeReordered
✔ [1984/1996] Built Risc0.Gadgets.OneHot2.Constraints.CodeParts
✔ [1986/1996] Built Risc0.Gadgets.OneHot2.Witness.CodeParts
✔ [1988/1996] Built Risc0.Gadgets.OneHot2.Constraints.CodeDrops
✔ [1990/1996] Built Risc0.Gadgets.OneHot2.Witness.CodeDrops
✔ [1992/1996] Built Risc0
✔ [1993/1996] Built Risc0:c.o
✔ [1994/1996] Built Main
✔ [1996/1996] Built risc0
Build completed successfully.

[]
Creating constraints weakest pre files
  0 - sorry
✖ [1992/1998] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      Code.part1;
        dropfelt { name := "%4" : FeltVar };
          Code.part2;
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar };
                dropfelt { name := "%10" : FeltVar };
                  Code.part3;
                    dropfelt { name := "%3" : FeltVar };
                      dropfelt { name := "%0" : FeltVar };
                        dropfelt { name := "%6" : FeltVar };
                          dropfelt { name := "%11" : FeltVar };
                            dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))["%3"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          (((st[props][{ name := "%1" : PropVar }] ← True)["%3"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                { name := "%3" : FeltVar }).get! -
            (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%2" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart0
RECEIVED(constraints)-------------
✖ [1992/1998] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      Code.part1;
        dropfelt { name := "%4" : FeltVar };
          Code.part2;
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar };
                dropfelt { name := "%10" : FeltVar };
                  Code.part3;
                    dropfelt { name := "%3" : FeltVar };
                      dropfelt { name := "%0" : FeltVar };
                        dropfelt { name := "%6" : FeltVar };
                          dropfelt { name := "%11" : FeltVar };
                            dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))["%3"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          (((st[props][{ name := "%1" : PropVar }] ← True)["%3"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                { name := "%3" : FeltVar }).get! -
            (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%2" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart0

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:24:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      Code.part1;
        dropfelt { name := "%4" : FeltVar };
          Code.part2;
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar };
                dropfelt { name := "%10" : FeltVar };
                  Code.part3;
                    dropfelt { name := "%3" : FeltVar };
                      dropfelt { name := "%0" : FeltVar };
                        dropfelt { name := "%6" : FeltVar };
                          dropfelt { name := "%11" : FeltVar };
                            dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))["%3"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          (((st[props][{ name := "%1" : PropVar }] ← True)["%3"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                { name := "%3" : FeltVar }).get! -
            (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%2" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part0_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart0.lean:39:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart0





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))["%3"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          (((st[props][{ name := "%1" : PropVar }] ← True)["%3"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                { name := "%3" : FeltVar }).get! -
            (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%2" : FeltVar }).get!) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) 
State transformer: "
        ((((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
              getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))["%3"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ))[felts][{ name := "%4" : FeltVar }] ←
          (((st[props][{ name := "%1" : PropVar }] ← True)["%3"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (1 : ℕ)).felts
                { name := "%3" : FeltVar }).get! -
            (((st[props][{ name := "%1" : PropVar }] ← True)["%2"] ←ₛ
                    getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%2" : FeltVar }).get!) "
Cumulative transformer: "Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]),
                ({ name := "data" : BufferVar }, [[some data0, some data1]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }) "
  0 - corrected
Part 1 of 4
  1 - sorry
✖ [1994/2000] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%4" : FeltVar };
      Code.part2;
        dropfelt { name := "%7" : FeltVar };
          dropfelt { name := "%8" : FeltVar };
            dropfelt { name := "%10" : FeltVar };
              Code.part3;
                dropfelt { name := "%3" : FeltVar };
                  dropfelt { name := "%0" : FeltVar };
                    dropfelt { name := "%6" : FeltVar };
                      dropfelt { name := "%11" : FeltVar };
                        dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%1" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part1_state_update
        ((({
                buffers :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                      [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                    [[some code0]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "code" : BufferVar },
                    { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
              True)[felts][{ name := "%3" : FeltVar }] ←
            data1)[felts][{ name := "%4" : FeltVar }] ←
          data1 - code0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1
RECEIVED(constraints)-------------
✖ [1994/2000] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%4" : FeltVar };
      Code.part2;
        dropfelt { name := "%7" : FeltVar };
          dropfelt { name := "%8" : FeltVar };
            dropfelt { name := "%10" : FeltVar };
              Code.part3;
                dropfelt { name := "%3" : FeltVar };
                  dropfelt { name := "%0" : FeltVar };
                    dropfelt { name := "%6" : FeltVar };
                      dropfelt { name := "%11" : FeltVar };
                        dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%1" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part1_state_update
        ((({
                buffers :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                      [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                    [[some code0]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "code" : BufferVar },
                    { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
              True)[felts][{ name := "%3" : FeltVar }] ←
            data1)[felts][{ name := "%4" : FeltVar }] ←
          data1 - code0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%4" : FeltVar };
      Code.part2;
        dropfelt { name := "%7" : FeltVar };
          dropfelt { name := "%8" : FeltVar };
            dropfelt { name := "%10" : FeltVar };
              Code.part3;
                dropfelt { name := "%3" : FeltVar };
                  dropfelt { name := "%0" : FeltVar };
                    dropfelt { name := "%6" : FeltVar };
                      dropfelt { name := "%11" : FeltVar };
                        dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%1" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) ⟦prog⟧) ↔
    Code.getReturn (part1_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart1.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part1_state_update
        ((({
                buffers :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                      [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                    [[some code0]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "code" : BufferVar },
                    { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
              True)[felts][{ name := "%3" : FeltVar }] ←
            data1)[felts][{ name := "%4" : FeltVar }] ←
          data1 - code0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%1" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part1_state_update
        ((({
                buffers :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                      [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                    [[some code0]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "code" : BufferVar },
                    { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
              True)[felts][{ name := "%3" : FeltVar }] ←
            data1)[felts][{ name := "%4" : FeltVar }] ←
          data1 - code0)) 
State transformer: "
        ((((st[props][{ name := "%5" : PropVar }] ←
                ((st.props { name := "%1" : PropVar }).get! ∧
                  (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))["%6"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) -
            ((((st[props][{ name := "%5" : PropVar }] ←
                        ((st.props { name := "%1" : PropVar }).get! ∧
                          (st.felts { name := "%4" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
                      (1 : Felt))["%6"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%6" : FeltVar }).get!) "
Cumulative transformer: "Code.getReturn
      (part1_state_update
        ((({
                buffers :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                      [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                    [[some code0]],
                bufferWidths :=
                  (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                vars :=
                  [{ name := "code" : BufferVar },
                    { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
              True)[felts][{ name := "%3" : FeltVar }] ←
            data1)[felts][{ name := "%4" : FeltVar }] ←
          data1 - code0)) "
  1 - corrected
✔ [1994/2000] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1
✔ [1995/2000] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart1:c.o
✔ [1996/2000] Built Risc0
✔ [1997/2000] Built Risc0:c.o
✔ [1998/2000] Built Main
✔ [2000/2000] Built risc0
Build completed successfully.
Part 2 of 4
  2 - sorry
✖ [1996/2002] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%7" : FeltVar };
      dropfelt { name := "%8" : FeltVar };
        dropfelt { name := "%10" : FeltVar };
          Code.part3;
            dropfelt { name := "%3" : FeltVar };
              dropfelt { name := "%0" : FeltVar };
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%11" : FeltVar };
                    dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! -
              (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%11" : FeltVar }] ←
          (st.felts { name := "%3" : FeltVar }).get! *
            ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%3" : FeltVar }).get!)) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part2_state_update
        (((((({
                      buffers :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                            [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                          [[some code0]],
                      bufferWidths :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                          (1 : ℕ),
                      cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                      vars :=
                        [{ name := "code" : BufferVar },
                          { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                    True)[felts][{ name := "%3" : FeltVar }] ←
                  data1)[props][{ name := "%5" : PropVar }] ←
                data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2
RECEIVED(constraints)-------------
✖ [1996/2002] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%7" : FeltVar };
      dropfelt { name := "%8" : FeltVar };
        dropfelt { name := "%10" : FeltVar };
          Code.part3;
            dropfelt { name := "%3" : FeltVar };
              dropfelt { name := "%0" : FeltVar };
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%11" : FeltVar };
                    dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! -
              (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%11" : FeltVar }] ←
          (st.felts { name := "%3" : FeltVar }).get! *
            ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%3" : FeltVar }).get!)) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part2_state_update
        (((((({
                      buffers :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                            [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                          [[some code0]],
                      bufferWidths :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                          (1 : ℕ),
                      cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                      vars :=
                        [{ name := "code" : BufferVar },
                          { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                    True)[felts][{ name := "%3" : FeltVar }] ←
                  data1)[props][{ name := "%5" : PropVar }] ←
                data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%7" : FeltVar };
      dropfelt { name := "%8" : FeltVar };
        dropfelt { name := "%10" : FeltVar };
          Code.part3;
            dropfelt { name := "%3" : FeltVar };
              dropfelt { name := "%0" : FeltVar };
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%11" : FeltVar };
                    dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! -
              (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%11" : FeltVar }] ←
          (st.felts { name := "%3" : FeltVar }).get! *
            ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%3" : FeltVar }).get!)) ⟦prog⟧) ↔
    Code.getReturn (part2_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart2.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part2_state_update
        (((((({
                      buffers :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                            [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                          [[some code0]],
                      bufferWidths :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                          (1 : ℕ),
                      cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                      vars :=
                        [{ name := "code" : BufferVar },
                          { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                    True)[felts][{ name := "%3" : FeltVar }] ←
                  data1)[props][{ name := "%5" : PropVar }] ←
                data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2





STATE TRANSFORMER--
--
--

        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! -
              (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%11" : FeltVar }] ←
          (st.felts { name := "%3" : FeltVar }).get! *
            ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%3" : FeltVar }).get!)) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part2_state_update
        (((((({
                      buffers :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                            [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                          [[some code0]],
                      bufferWidths :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                          (1 : ℕ),
                      cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                      vars :=
                        [{ name := "code" : BufferVar },
                          { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                    True)[felts][{ name := "%3" : FeltVar }] ←
                  data1)[props][{ name := "%5" : PropVar }] ←
                data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) 
State transformer: "
        ((((st[felts][{ name := "%8" : FeltVar }] ←
                (st.felts { name := "%6" : FeltVar }).get! *
                  (st.felts { name := "%7" : FeltVar }).get!)[props][{ name := "%9" : PropVar }] ←
              ((st.props { name := "%5" : PropVar }).get! ∧
                ((st.felts { name := "%6" : FeltVar }).get! = (0 : Felt) ∨
                  (st.felts { name := "%7" : FeltVar }).get! = (0 : Felt))))[felts][{ name := "%10" : FeltVar }] ←
            (st.felts { name := "%0" : FeltVar }).get! -
              (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%11" : FeltVar }] ←
          (st.felts { name := "%3" : FeltVar }).get! *
            ((st.felts { name := "%0" : FeltVar }).get! - (st.felts { name := "%3" : FeltVar }).get!)) "
Cumulative transformer: "Code.getReturn
      (part2_state_update
        (((((({
                      buffers :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                            [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                          [[some code0]],
                      bufferWidths :=
                        (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                          (1 : ℕ),
                      cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                      vars :=
                        [{ name := "code" : BufferVar },
                          { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                    True)[felts][{ name := "%3" : FeltVar }] ←
                  data1)[props][{ name := "%5" : PropVar }] ←
                data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
              (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
            data0)[felts][{ name := "%7" : FeltVar }] ←
          (1 : Felt) - data0)) "
  2 - corrected
✔ [1996/2002] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2
✔ [1997/2002] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart2:c.o
✔ [1998/2002] Built Risc0
✔ [1999/2002] Built Risc0:c.o
✔ [2000/2002] Built Main
✔ [2002/2002] Built risc0
Build completed successfully.
  3 - sorry
✖ [1998/2004] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%3" : FeltVar };
      dropfelt { name := "%0" : FeltVar };
        dropfelt { name := "%6" : FeltVar };
          dropfelt { name := "%11" : FeltVar };
            dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%12" : PropVar }] ←
                ((st.props { name := "%9" : PropVar }).get! ∧
                  (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%13" : FeltVar }] ←
              (st.felts { name := "%6" : FeltVar }).get! +
                (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%15" : PropVar }] ←
          (((st.props { name := "%9" : PropVar }).get! ∧ (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)) ∧
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get! =
              (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part3_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part3_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                            [[some code0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "code" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%3" : FeltVar }] ←
                    data1)[props][{ name := "%5" : PropVar }] ←
                  data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
                (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
              data0)[props][{ name := "%9" : PropVar }] ←
            (data1 - code0 = (0 : Felt) ∧
              (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))))[felts][{ name := "%11" : FeltVar }] ←
          data1 * ((1 : Felt) - data1))) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
RECEIVED(constraints)-------------
✖ [1998/2004] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%3" : FeltVar };
      dropfelt { name := "%0" : FeltVar };
        dropfelt { name := "%6" : FeltVar };
          dropfelt { name := "%11" : FeltVar };
            dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%12" : PropVar }] ←
                ((st.props { name := "%9" : PropVar }).get! ∧
                  (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%13" : FeltVar }] ←
              (st.felts { name := "%6" : FeltVar }).get! +
                (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%15" : PropVar }] ←
          (((st.props { name := "%9" : PropVar }).get! ∧ (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)) ∧
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get! =
              (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part3_state_update st)
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part3_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                            [[some code0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "code" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%3" : FeltVar }] ←
                    data1)[props][{ name := "%5" : PropVar }] ←
                  data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
                (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
              data0)[props][{ name := "%9" : PropVar }] ←
            (data1 - code0 = (0 : Felt) ∧
              (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))))[felts][{ name := "%11" : FeltVar }] ←
          data1 * ((1 : Felt) - data1))) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:25:44: unsolved goals
st : State
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%3" : FeltVar };
      dropfelt { name := "%0" : FeltVar };
        dropfelt { name := "%6" : FeltVar };
          dropfelt { name := "%11" : FeltVar };
            dropfelt { name := "%13" : FeltVar }; dropfelt { name := "%14" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[props][{ name := "%12" : PropVar }] ←
                ((st.props { name := "%9" : PropVar }).get! ∧
                  (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%13" : FeltVar }] ←
              (st.felts { name := "%6" : FeltVar }).get! +
                (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%15" : PropVar }] ←
          (((st.props { name := "%9" : PropVar }).get! ∧ (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)) ∧
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get! =
              (0 : Felt))) ⟦prog⟧) ↔
    Code.getReturn (part3_state_update st)




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:57:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 data0 data1 : Felt
⊢ Code.getReturn
      (part3_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                            [[some code0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "code" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%3" : FeltVar }] ←
                    data1)[props][{ name := "%5" : PropVar }] ←
                  data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
                (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
              data0)[props][{ name := "%9" : PropVar }] ←
            (data1 - code0 = (0 : Felt) ∧
              (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))))[felts][{ name := "%11" : FeltVar }] ←
          data1 * ((1 : Felt) - data1))) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3





STATE TRANSFORMER--
--
--

        ((((st[props][{ name := "%12" : PropVar }] ←
                ((st.props { name := "%9" : PropVar }).get! ∧
                  (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%13" : FeltVar }] ←
              (st.felts { name := "%6" : FeltVar }).get! +
                (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%15" : PropVar }] ←
          (((st.props { name := "%9" : PropVar }).get! ∧ (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)) ∧
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get! =
              (0 : Felt))) 




CUMULATIVE STATE TRANSFORMER--
--
--
Code.getReturn
      (part3_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                            [[some code0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "code" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%3" : FeltVar }] ←
                    data1)[props][{ name := "%5" : PropVar }] ←
                  data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
                (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
              data0)[props][{ name := "%9" : PropVar }] ←
            (data1 - code0 = (0 : Felt) ∧
              (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))))[felts][{ name := "%11" : FeltVar }] ←
          data1 * ((1 : Felt) - data1))) 
State transformer: "
        ((((st[props][{ name := "%12" : PropVar }] ←
                ((st.props { name := "%9" : PropVar }).get! ∧
                  (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)))[felts][{ name := "%13" : FeltVar }] ←
              (st.felts { name := "%6" : FeltVar }).get! +
                (st.felts { name := "%3" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
              (st.felts { name := "%0" : FeltVar }).get!)[props][{ name := "%15" : PropVar }] ←
          (((st.props { name := "%9" : PropVar }).get! ∧ (st.felts { name := "%11" : FeltVar }).get! = (0 : Felt)) ∧
            (st.felts { name := "%6" : FeltVar }).get! + (st.felts { name := "%3" : FeltVar }).get! -
                (st.felts { name := "%0" : FeltVar }).get! =
              (0 : Felt))) "
Cumulative transformer: "Code.getReturn
      (part3_state_update
        ((((((({
                        buffers :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                              [[some data0, some data1]])[{ name := "code" : BufferVar }] ←ₘ
                            [[some code0]],
                        bufferWidths :=
                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                            (1 : ℕ),
                        cycle := (0 : ℕ), felts := Map.empty, isFailed := False, props := Map.empty,
                        vars :=
                          [{ name := "code" : BufferVar },
                            { name := "data" : BufferVar }] }[props][{ name := "%1" : PropVar }] ←
                      True)[felts][{ name := "%3" : FeltVar }] ←
                    data1)[props][{ name := "%5" : PropVar }] ←
                  data1 - code0 = (0 : Felt))[felts][{ name := "%0" : FeltVar }] ←
                (1 : Felt))[felts][{ name := "%6" : FeltVar }] ←
              data0)[props][{ name := "%9" : PropVar }] ←
            (data1 - code0 = (0 : Felt) ∧
              (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))))[felts][{ name := "%11" : FeltVar }] ←
          data1 * ((1 : Felt) - data1))) "
  3 - corrected
✖ [1998/2004] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:96:11: unsolved goals
code0 data0 data1 : Felt
⊢ ((data1 - code0 = (0 : Felt) ∧ (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))) ∧
        (data1 = (0 : Felt) ∨ (1 : Felt) - data1 = (0 : Felt))) ∧
      data0 + data1 - (1 : Felt) = (0 : Felt) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
closed form:



 ✖ [1998/2004] Building Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.c --json
error: ././././Risc0/Gadgets/OneHot2/Constraints/WeakestPresPart3.lean:96:11: unsolved goals
code0 data0 data1 : Felt
⊢ ((data1 - code0 = (0 : Felt) ∧ (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))) ∧
        (data1 = (0 : Felt) ∨ (1 : Felt) - data1 = (0 : Felt))) ∧
      data0 + data1 - (1 : Felt) = (0 : Felt) ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3


 end closed form
 ((data1 - code0 = (0 : Felt) ∧ (data0 = (0 : Felt) ∨ (1 : Felt) - data0 = (0 : Felt))) ∧
        (data1 = (0 : Felt) ∨ (1 : Felt) - data1 = (0 : Felt))) ∧
      data0 + data1 - (1 : Felt) = (0 : Felt) 
  closed form
✔ [1998/2004] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
✔ [1999/2004] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3:c.o
✔ [2000/2004] Built Risc0
✔ [2001/2004] Built Risc0:c.o
✔ [2002/2004] Built Main
✔ [2004/2004] Built risc0
Build completed successfully.
Creating witness weakest pre files
  0 - sorry
---stdout---:


✔ [1998/2004] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3
✔ [1999/2004] Built Risc0.Gadgets.OneHot2.Constraints.WeakestPresPart3:c.o
✔ [2000/2004] Built Risc0
✔ [2001/2004] Built Risc0:c.o
✔ [2002/2004] Built Main
✔ [2004/2004] Built risc0
Build completed successfully.

Done
✖ [2000/2006] Building Risc0.Gadgets.OneHot2.Witness.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:24:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%12" : FeltVar };
      Code.part1;
        dropfelt { name := "%13" : FeltVar };
          dropfelt { name := "%14" : FeltVar };
            Code.part2;
              dropfelt { name := "%2" : FeltVar };
                dropfelt { name := "%4" : FeltVar };
                  Code.part3;
                    dropfelt { name := "%6" : FeltVar };
                      dropfelt { name := "%7" : FeltVar };
                        dropfelt { name := "%8" : FeltVar };
                          Code.part4;
                            dropfelt { name := "%0" : FeltVar };
                              dropfelt { name := "%3" : FeltVar };
                                dropfelt { name := "%5" : FeltVar };
                                  dropfelt { name := "%9" : FeltVar };
                                    dropfelt { name := "%10" : FeltVar };
                                      Code.part5;
                                        dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%12" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part0_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart0
RECEIVED(witness)-------------
✖ [2000/2006] Building Risc0.Gadgets.OneHot2.Witness.WeakestPresPart0
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.c --json
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:11:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:24:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%12" : FeltVar };
      Code.part1;
        dropfelt { name := "%13" : FeltVar };
          dropfelt { name := "%14" : FeltVar };
            Code.part2;
              dropfelt { name := "%2" : FeltVar };
                dropfelt { name := "%4" : FeltVar };
                  Code.part3;
                    dropfelt { name := "%6" : FeltVar };
                      dropfelt { name := "%7" : FeltVar };
                        dropfelt { name := "%8" : FeltVar };
                          Code.part4;
                            dropfelt { name := "%0" : FeltVar };
                              dropfelt { name := "%3" : FeltVar };
                                dropfelt { name := "%5" : FeltVar };
                                  dropfelt { name := "%9" : FeltVar };
                                    dropfelt { name := "%10" : FeltVar };
                                      Code.part5;
                                        dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%12" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part0_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart0

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:24:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%12" : FeltVar };
      Code.part1;
        dropfelt { name := "%13" : FeltVar };
          dropfelt { name := "%14" : FeltVar };
            Code.part2;
              dropfelt { name := "%2" : FeltVar };
                dropfelt { name := "%4" : FeltVar };
                  Code.part3;
                    dropfelt { name := "%6" : FeltVar };
                      dropfelt { name := "%7" : FeltVar };
                        dropfelt { name := "%8" : FeltVar };
                          Code.part4;
                            dropfelt { name := "%0" : FeltVar };
                              dropfelt { name := "%3" : FeltVar };
                                dropfelt { name := "%5" : FeltVar };
                                  dropfelt { name := "%9" : FeltVar };
                                    dropfelt { name := "%10" : FeltVar };
                                      Code.part5;
                                        dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%12" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part0_state_update st) [data0, data1]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart0.lean:40:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart0

State transformer: "
        ((((st["%2"] ←ₛ
                  getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%12" : FeltVar }] ←
                if
                    ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                          { name := "%2" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (0 : ℕ)
            (if
                ((st["%2"] ←ₛ getImpl st { name := "code" : BufferVar } (0 : Back) (0 : ℕ)).felts
                      { name := "%2" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)) "
Cumulative transformer: "Code.getReturn
      (part0_state_update
        {
          buffers :=
            Map.fromList
              [({ name := "code" : BufferVar }, [[some code0]]), ({ name := "data" : BufferVar }, [[none, none]])],
          bufferWidths :=
            Map.fromList [({ name := "code" : BufferVar }, (1 : ℕ)), ({ name := "data" : BufferVar }, (2 : ℕ))],
          cycle := (0 : ℕ), felts := Map.empty, isFailed := false = true, props := Map.empty,
          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] })
      ([data0, data1]) "
  0 - corrected
Part 1 of 6
  1 - sorry
✖ [2002/2008] Building Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%13" : FeltVar };
      dropfelt { name := "%14" : FeltVar };
        Code.part2;
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%4" : FeltVar };
              Code.part3;
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%7" : FeltVar };
                    dropfelt { name := "%8" : FeltVar };
                      Code.part4;
                        dropfelt { name := "%0" : FeltVar };
                          dropfelt { name := "%3" : FeltVar };
                            dropfelt { name := "%5" : FeltVar };
                              dropfelt { name := "%9" : FeltVar };
                                dropfelt { name := "%10" : FeltVar };
                                  Code.part5;
                                    dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%13" : FeltVar }] ←
                  (st.felts { name := "%2" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                if
                    (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (1 : ℕ)
            (if
                (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))["%3"] ←ₛ
          getImpl
            (((st[felts][{ name := "%13" : FeltVar }] ←
                    (st.felts { name := "%2" : FeltVar }).get! -
                      (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                  if
                      (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt) then
                    (1 : Felt)
                  else (0 : Felt)).set!
              { name := "data" : BufferVar } (1 : ℕ)
              (if
                  (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                    (0 : Felt) then
                (1 : Felt)
              else (0 : Felt)))
            { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part1_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1
RECEIVED(witness)-------------
✖ [2002/2008] Building Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.c --json
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%13" : FeltVar };
      dropfelt { name := "%14" : FeltVar };
        Code.part2;
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%4" : FeltVar };
              Code.part3;
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%7" : FeltVar };
                    dropfelt { name := "%8" : FeltVar };
                      Code.part4;
                        dropfelt { name := "%0" : FeltVar };
                          dropfelt { name := "%3" : FeltVar };
                            dropfelt { name := "%5" : FeltVar };
                              dropfelt { name := "%9" : FeltVar };
                                dropfelt { name := "%10" : FeltVar };
                                  Code.part5;
                                    dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%13" : FeltVar }] ←
                  (st.felts { name := "%2" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                if
                    (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (1 : ℕ)
            (if
                (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))["%3"] ←ₛ
          getImpl
            (((st[felts][{ name := "%13" : FeltVar }] ←
                    (st.felts { name := "%2" : FeltVar }).get! -
                      (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                  if
                      (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt) then
                    (1 : Felt)
                  else (0 : Felt)).set!
              { name := "data" : BufferVar } (1 : ℕ)
              (if
                  (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                    (0 : Felt) then
                (1 : Felt)
              else (0 : Felt)))
            { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part1_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%13" : FeltVar };
      dropfelt { name := "%14" : FeltVar };
        Code.part2;
          dropfelt { name := "%2" : FeltVar };
            dropfelt { name := "%4" : FeltVar };
              Code.part3;
                dropfelt { name := "%6" : FeltVar };
                  dropfelt { name := "%7" : FeltVar };
                    dropfelt { name := "%8" : FeltVar };
                      Code.part4;
                        dropfelt { name := "%0" : FeltVar };
                          dropfelt { name := "%3" : FeltVar };
                            dropfelt { name := "%5" : FeltVar };
                              dropfelt { name := "%9" : FeltVar };
                                dropfelt { name := "%10" : FeltVar };
                                  Code.part5;
                                    dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        ((((st[felts][{ name := "%13" : FeltVar }] ←
                  (st.felts { name := "%2" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                if
                    (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (1 : ℕ)
            (if
                (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))["%3"] ←ₛ
          getImpl
            (((st[felts][{ name := "%13" : FeltVar }] ←
                    (st.felts { name := "%2" : FeltVar }).get! -
                      (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                  if
                      (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt) then
                    (1 : Felt)
                  else (0 : Felt)).set!
              { name := "data" : BufferVar } (1 : ℕ)
              (if
                  (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                    (0 : Felt) then
                (1 : Felt)
              else (0 : Felt)))
            { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part1_state_update st) [data0, data1]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart1.lean:58:4: The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
code0 : Felt
data0 data1 : Option Felt
⊢ Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      [data0, data1] ↔
    sorryAx Prop
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1

State transformer: "
        ((((st[felts][{ name := "%13" : FeltVar }] ←
                  (st.felts { name := "%2" : FeltVar }).get! -
                    (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                if
                    (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                      (0 : Felt) then
                  (1 : Felt)
                else (0 : Felt)).set!
            { name := "data" : BufferVar } (1 : ℕ)
            (if
                (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                  (0 : Felt) then
              (1 : Felt)
            else (0 : Felt)))["%3"] ←ₛ
          getImpl
            (((st[felts][{ name := "%13" : FeltVar }] ←
                    (st.felts { name := "%2" : FeltVar }).get! -
                      (st.felts { name := "%0" : FeltVar }).get!)[felts][{ name := "%14" : FeltVar }] ←
                  if
                      (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                        (0 : Felt) then
                    (1 : Felt)
                  else (0 : Felt)).set!
              { name := "data" : BufferVar } (1 : ℕ)
              (if
                  (st.felts { name := "%2" : FeltVar }).get! - (st.felts { name := "%0" : FeltVar }).get! =
                    (0 : Felt) then
                (1 : Felt)
              else (0 : Felt)))
            { name := "data" : BufferVar } (0 : Back) (1 : ℕ)) "
Cumulative transformer: "Code.getReturn
      (part1_state_update
        ({
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ), felts := Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0, isFailed := False,
            props := Map.empty,
            vars :=
              [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }[felts][{ name := "%0" : FeltVar }] ←
          (1 : Felt)))
      ([data0, data1]) "
  1 - corrected
✔ [2002/2008] Built Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1
✔ [2003/2008] Built Risc0.Gadgets.OneHot2.Witness.WeakestPresPart1:c.o
✔ [2004/2008] Built Risc0
✔ [2005/2008] Built Risc0:c.o
✔ [2006/2008] Built Main
✔ [2008/2008] Built risc0
Build completed successfully.
Part 2 of 6
  2 - sorry
✖ [2004/2010] Building Risc0.Gadgets.OneHot2.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        Code.part3;
          dropfelt { name := "%6" : FeltVar };
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar };
                Code.part4;
                  dropfelt { name := "%0" : FeltVar };
                    dropfelt { name := "%3" : FeltVar };
                      dropfelt { name := "%5" : FeltVar };
                        dropfelt { name := "%9" : FeltVar };
                          dropfelt { name := "%10" : FeltVar };
                            Code.part5; dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (((withEqZero ((st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%4" : FeltVar }] ←
                (st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!))["%5"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%6" : FeltVar }] ←
          (st.felts { name := "%0" : FeltVar }).get! -
            (((withEqZero ((st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
                      (st[felts][{ name := "%4" : FeltVar }] ←
                        (st.felts { name := "%3" : FeltVar }).get! -
                          (st.felts { name := "%2" : FeltVar }).get!))["%5"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%5" : FeltVar }).get!) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part2_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:47:4: tactic 'unfold' failed to unfold 'Risc0.OneHot2.Witness.WP.part1_drops' at
  (0 : Back) ≤
      (match
          if
              (match
                  match
                    if h :
                        (1 : ℕ) <
                          List.length
                            (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                      some
                        (Buffer.getBufferAtTime! [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                    else none with
                  | some e => e
                  | none => outOfBounds,
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                | some a, b => a == b
                | none, x => false) =
                true then
            some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
          else
            if
                (match
                    if h :
                        (1 : ℕ) <
                          List.length
                            (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                      some
                        (Buffer.getBufferAtTime! [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                    else none with
                  | some e => e
                  | none => outOfBounds) =
                  none then
              some
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                    some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
            else none with
        | some b =>
          {
            buffers :=
              ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      none]])[{ name := "data" : BufferVar }] ←ₘ
                b,
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                    (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                  code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
        | none =>
          {
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                    (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                  code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := True, props := Map.empty,
            vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle ∧
    { name := "data" : BufferVar } ∈
        (match
            if
                (match
                    match
                      if h :
                          (1 : ℕ) <
                            List.length
                              (Buffer.getBufferAtTime!
                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                        some
                          (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                      else none with
                    | some e => e
                    | none => outOfBounds,
                    if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                  | some a, b => a == b
                  | none, x => false) =
                  true then
              some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
            else
              if
                  (match
                      if h :
                          (1 : ℕ) <
                            List.length
                              (Buffer.getBufferAtTime!
                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                        some
                          (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                      else none with
                    | some e => e
                    | none => outOfBounds) =
                    none then
                some
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
              else none with
          | some b =>
            {
              buffers :=
                ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        none]])[{ name := "data" : BufferVar }] ←ₘ
                  b,
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                      (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                    code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := False, props := Map.empty,
              vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
          | none =>
            {
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                      (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                    code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := True, props := Map.empty,
              vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).vars ∧
      ((1 : ℕ) <
          match
            (match
                  if
                      (match
                          match
                            if h :
                                (1 : ℕ) <
                                  List.length
                                    (Buffer.getBufferAtTime!
                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                              some
                                (Buffer.getBufferAtTime!
                                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                            else none with
                          | some e => e
                          | none => outOfBounds,
                          if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                        | some a, b => a == b
                        | none, x => false) =
                        true then
                    some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                  else
                    if
                        (match
                            if h :
                                (1 : ℕ) <
                                  List.length
                                    (Buffer.getBufferAtTime!
                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                              some
                                (Buffer.getBufferAtTime!
                                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                            else none with
                          | some e => e
                          | none => outOfBounds) =
                          none then
                      some
                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                            some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                    else none with
                | some b =>
                  {
                    buffers :=
                      ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                          [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                              none]])[{ name := "data" : BufferVar }] ←ₘ
                        b,
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ),
                    felts :=
                      (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                            (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                          code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                        if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                    isFailed := False, props := Map.empty,
                    vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                | none =>
                  {
                    buffers :=
                      (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ),
                    felts :=
                      (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                            (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                          code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                        if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                    isFailed := True, props := Map.empty,
                    vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).bufferWidths
              { name := "data" : BufferVar } with
          | some x => x
          | none => panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ) "value is none") ∧
        (match
              if h :
                  (1 : ℕ) <
                    (match
                        if h :
                            Buffer.Idx.time
                                ((match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                    Back.toNat (0 : Back),
                                  (1 : ℕ)) <
                              List.length
                                (match
                                  (match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                    { name := "data" : BufferVar } with
                                | some x => x
                                | none =>
                                  panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                    "value is none") then
                          some
                            (match
                                (match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                  { name := "data" : BufferVar } with
                              | some x => x
                              | none =>
                                panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                  "value is none")[Buffer.Idx.time
                                ((match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                    Back.toNat (0 : Back),
                                  (1 : ℕ))]
                        else none with
                      | some e => e
                      | none => outOfBounds).length then
                some
                  (match
                      if h :
                          Buffer.Idx.time
                              ((match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                  Back.toNat (0 : Back),
                                (1 : ℕ)) <
                            List.length
                              (match
                                (match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                  { name := "data" : BufferVar } with
                              | some x => x
                              | none =>
                                panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                  "value is none") then
                        some
                          (match
                              (match
                                    if
                                        (match
                                            match
                                              if h :
                                                  (1 : ℕ) <
                                                    List.length
                                                      (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                some
                                                  (Buffer.getBufferAtTime!
                                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                          none]]
                                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                              else none with
                                            | some e => e
                                            | none => outOfBounds,
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                          | some a, b => a == b
                                          | none, x => false) =
                                          true then
                                      some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    else
                                      if
                                          (match
                                              if h :
                                                  (1 : ℕ) <
                                                    List.length
                                                      (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                some
                                                  (Buffer.getBufferAtTime!
                                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                          none]]
                                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                              else none with
                                            | some e => e
                                            | none => outOfBounds) =
                                            none then
                                        some
                                          [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                              some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : ⋯)),
                                              ⋯],
                                            ⋯]
                                      else ⋯ with
                                  | ⋯ => ⋯
                                  | ⋯ => ⋯).buffers
                                ⋯ with
                            | ⋯ => ⋯
                            | ⋯ => ⋯)[⋯]
                      else ⋯ with
                    | ⋯ => ⋯
                    | ⋯ => ⋯)[⋯]
              else ⋯ with
            | ⋯ => ⋯
            | ⋯ => ⋯).isSome =
          ⋯
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart2
RECEIVED(witness)-------------
✖ [2004/2010] Building Risc0.Gadgets.OneHot2.Witness.WeakestPresPart2
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib LD_LIBRARY_PATH= /home/ferinko/.elan/toolchains/leanprover--lean4---v4.11.0-rc1/bin/lean -Dlinter.deprecated=false -Dlinter.suspiciousUnexpanderPatterns=false -Dlinter.unusedVariables=false -DwarningAsError=true ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean -R ./././. -o ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.olean -i ././.lake/build/lib/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.ilean -c ././.lake/build/ir/Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.c --json
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:12:4: declaration uses 'sorry'
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        Code.part3;
          dropfelt { name := "%6" : FeltVar };
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar };
                Code.part4;
                  dropfelt { name := "%0" : FeltVar };
                    dropfelt { name := "%3" : FeltVar };
                      dropfelt { name := "%5" : FeltVar };
                        dropfelt { name := "%9" : FeltVar };
                          dropfelt { name := "%10" : FeltVar };
                            Code.part5; dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (((withEqZero ((st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%4" : FeltVar }] ←
                (st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!))["%5"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%6" : FeltVar }] ←
          (st.felts { name := "%0" : FeltVar }).get! -
            (((withEqZero ((st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
                      (st[felts][{ name := "%4" : FeltVar }] ←
                        (st.felts { name := "%3" : FeltVar }).get! -
                          (st.felts { name := "%2" : FeltVar }).get!))["%5"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%5" : FeltVar }).get!) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part2_state_update st) [data0, data1]
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:47:4: tactic 'unfold' failed to unfold 'Risc0.OneHot2.Witness.WP.part1_drops' at
  (0 : Back) ≤
      (match
          if
              (match
                  match
                    if h :
                        (1 : ℕ) <
                          List.length
                            (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                      some
                        (Buffer.getBufferAtTime! [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                    else none with
                  | some e => e
                  | none => outOfBounds,
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                | some a, b => a == b
                | none, x => false) =
                true then
            some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
          else
            if
                (match
                    if h :
                        (1 : ℕ) <
                          List.length
                            (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                      some
                        (Buffer.getBufferAtTime! [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                    else none with
                  | some e => e
                  | none => outOfBounds) =
                  none then
              some
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                    some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
            else none with
        | some b =>
          {
            buffers :=
              ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      none]])[{ name := "data" : BufferVar }] ←ₘ
                b,
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                    (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                  code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
        | none =>
          {
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                    (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                  code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := True, props := Map.empty,
            vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle ∧
    { name := "data" : BufferVar } ∈
        (match
            if
                (match
                    match
                      if h :
                          (1 : ℕ) <
                            List.length
                              (Buffer.getBufferAtTime!
                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                        some
                          (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                      else none with
                    | some e => e
                    | none => outOfBounds,
                    if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                  | some a, b => a == b
                  | none, x => false) =
                  true then
              some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
            else
              if
                  (match
                      if h :
                          (1 : ℕ) <
                            List.length
                              (Buffer.getBufferAtTime!
                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                        some
                          (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                      else none with
                    | some e => e
                    | none => outOfBounds) =
                    none then
                some
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
              else none with
          | some b =>
            {
              buffers :=
                ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        none]])[{ name := "data" : BufferVar }] ←ₘ
                  b,
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                      (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                    code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := False, props := Map.empty,
              vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
          | none =>
            {
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                      (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                    code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := True, props := Map.empty,
              vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).vars ∧
      ((1 : ℕ) <
          match
            (match
                  if
                      (match
                          match
                            if h :
                                (1 : ℕ) <
                                  List.length
                                    (Buffer.getBufferAtTime!
                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                              some
                                (Buffer.getBufferAtTime!
                                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                            else none with
                          | some e => e
                          | none => outOfBounds,
                          if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                        | some a, b => a == b
                        | none, x => false) =
                        true then
                    some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                  else
                    if
                        (match
                            if h :
                                (1 : ℕ) <
                                  List.length
                                    (Buffer.getBufferAtTime!
                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                              some
                                (Buffer.getBufferAtTime!
                                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                            else none with
                          | some e => e
                          | none => outOfBounds) =
                          none then
                      some
                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                            some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                    else none with
                | some b =>
                  {
                    buffers :=
                      ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                          [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                              none]])[{ name := "data" : BufferVar }] ←ₘ
                        b,
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ),
                    felts :=
                      (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                            (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                          code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                        if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                    isFailed := False, props := Map.empty,
                    vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                | none =>
                  {
                    buffers :=
                      (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ),
                    felts :=
                      (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                            (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                          code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                        if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                    isFailed := True, props := Map.empty,
                    vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).bufferWidths
              { name := "data" : BufferVar } with
          | some x => x
          | none => panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ) "value is none") ∧
        (match
              if h :
                  (1 : ℕ) <
                    (match
                        if h :
                            Buffer.Idx.time
                                ((match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                    Back.toNat (0 : Back),
                                  (1 : ℕ)) <
                              List.length
                                (match
                                  (match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                    { name := "data" : BufferVar } with
                                | some x => x
                                | none =>
                                  panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                    "value is none") then
                          some
                            (match
                                (match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                  { name := "data" : BufferVar } with
                              | some x => x
                              | none =>
                                panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                  "value is none")[Buffer.Idx.time
                                ((match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                    Back.toNat (0 : Back),
                                  (1 : ℕ))]
                        else none with
                      | some e => e
                      | none => outOfBounds).length then
                some
                  (match
                      if h :
                          Buffer.Idx.time
                              ((match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                  Back.toNat (0 : Back),
                                (1 : ℕ)) <
                            List.length
                              (match
                                (match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                  { name := "data" : BufferVar } with
                              | some x => x
                              | none =>
                                panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                  "value is none") then
                        some
                          (match
                              (match
                                    if
                                        (match
                                            match
                                              if h :
                                                  (1 : ℕ) <
                                                    List.length
                                                      (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                some
                                                  (Buffer.getBufferAtTime!
                                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                          none]]
                                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                              else none with
                                            | some e => e
                                            | none => outOfBounds,
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                          | some a, b => a == b
                                          | none, x => false) =
                                          true then
                                      some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    else
                                      if
                                          (match
                                              if h :
                                                  (1 : ℕ) <
                                                    List.length
                                                      (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                some
                                                  (Buffer.getBufferAtTime!
                                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                          none]]
                                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                              else none with
                                            | some e => e
                                            | none => outOfBounds) =
                                            none then
                                        some
                                          [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                              some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : ⋯)),
                                              ⋯],
                                            ⋯]
                                      else ⋯ with
                                  | ⋯ => ⋯
                                  | ⋯ => ⋯).buffers
                                ⋯ with
                            | ⋯ => ⋯
                            | ⋯ => ⋯)[⋯]
                      else ⋯ with
                    | ⋯ => ⋯
                    | ⋯ => ⋯)[⋯]
              else ⋯ with
            | ⋯ => ⋯
            | ⋯ => ⋯).isSome =
          ⋯
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart2

FIRST ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:25:61: unsolved goals
st : State
data0 data1 : Option Felt
prog : MLIR IsNondet.NotInNondet
eq :
  (dropfelt { name := "%2" : FeltVar };
      dropfelt { name := "%4" : FeltVar };
        Code.part3;
          dropfelt { name := "%6" : FeltVar };
            dropfelt { name := "%7" : FeltVar };
              dropfelt { name := "%8" : FeltVar };
                Code.part4;
                  dropfelt { name := "%0" : FeltVar };
                    dropfelt { name := "%3" : FeltVar };
                      dropfelt { name := "%5" : FeltVar };
                        dropfelt { name := "%9" : FeltVar };
                          dropfelt { name := "%10" : FeltVar };
                            Code.part5; dropfelt { name := "%11" : FeltVar }; dropfelt { name := "%1" : FeltVar }) =
    prog
⊢ Code.getReturn
      (Γ
        (((withEqZero ((st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
              (st[felts][{ name := "%4" : FeltVar }] ←
                (st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!))["%5"] ←ₛ
            getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ))[felts][{ name := "%6" : FeltVar }] ←
          (st.felts { name := "%0" : FeltVar }).get! -
            (((withEqZero ((st.felts { name := "%3" : FeltVar }).get! - (st.felts { name := "%2" : FeltVar }).get!)
                      (st[felts][{ name := "%4" : FeltVar }] ←
                        (st.felts { name := "%3" : FeltVar }).get! -
                          (st.felts { name := "%2" : FeltVar }).get!))["%5"] ←ₛ
                    getImpl st { name := "data" : BufferVar } (0 : Back) (0 : ℕ)).felts
                { name := "%5" : FeltVar }).get!) ⟦prog⟧)
      [data0, data1] ↔
    Code.getReturn (part2_state_update st) [data0, data1]




SECOND ERROR--
--
--
error: ././././Risc0/Gadgets/OneHot2/Witness/WeakestPresPart2.lean:47:4: tactic 'unfold' failed to unfold 'Risc0.OneHot2.Witness.WP.part1_drops' at
  (0 : Back) ≤
      (match
          if
              (match
                  match
                    if h :
                        (1 : ℕ) <
                          List.length
                            (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                      some
                        (Buffer.getBufferAtTime! [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                    else none with
                  | some e => e
                  | none => outOfBounds,
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                | some a, b => a == b
                | none, x => false) =
                true then
            some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
          else
            if
                (match
                    if h :
                        (1 : ℕ) <
                          List.length
                            (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                      some
                        (Buffer.getBufferAtTime! [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                    else none with
                  | some e => e
                  | none => outOfBounds) =
                  none then
              some
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                    some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
            else none with
        | some b =>
          {
            buffers :=
              ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      none]])[{ name := "data" : BufferVar }] ←ₘ
                b,
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                    (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                  code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := False, props := Map.empty,
            vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
        | none =>
          {
            buffers :=
              (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
            bufferWidths :=
              (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
            cycle := (0 : ℕ),
            felts :=
              (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                    (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                  code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
            isFailed := True, props := Map.empty,
            vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle ∧
    { name := "data" : BufferVar } ∈
        (match
            if
                (match
                    match
                      if h :
                          (1 : ℕ) <
                            List.length
                              (Buffer.getBufferAtTime!
                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                        some
                          (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                      else none with
                    | some e => e
                    | none => outOfBounds,
                    if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                  | some a, b => a == b
                  | none, x => false) =
                  true then
              some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
            else
              if
                  (match
                      if h :
                          (1 : ℕ) <
                            List.length
                              (Buffer.getBufferAtTime!
                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                        some
                          (Buffer.getBufferAtTime!
                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                              (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                      else none with
                    | some e => e
                    | none => outOfBounds) =
                    none then
                some
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                      some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
              else none with
          | some b =>
            {
              buffers :=
                ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                        none]])[{ name := "data" : BufferVar }] ←ₘ
                  b,
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                      (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                    code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := False, props := Map.empty,
              vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
          | none =>
            {
              buffers :=
                (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                  [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
              bufferWidths :=
                (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
              cycle := (0 : ℕ),
              felts :=
                (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                      (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                    code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                  if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
              isFailed := True, props := Map.empty,
              vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).vars ∧
      ((1 : ℕ) <
          match
            (match
                  if
                      (match
                          match
                            if h :
                                (1 : ℕ) <
                                  List.length
                                    (Buffer.getBufferAtTime!
                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                              some
                                (Buffer.getBufferAtTime!
                                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                            else none with
                          | some e => e
                          | none => outOfBounds,
                          if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                        | some a, b => a == b
                        | none, x => false) =
                        true then
                    some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                  else
                    if
                        (match
                            if h :
                                (1 : ℕ) <
                                  List.length
                                    (Buffer.getBufferAtTime!
                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                              some
                                (Buffer.getBufferAtTime!
                                    [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                            else none with
                          | some e => e
                          | none => outOfBounds) =
                          none then
                      some
                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                            some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                    else none with
                | some b =>
                  {
                    buffers :=
                      ((Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                          [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                              none]])[{ name := "data" : BufferVar }] ←ₘ
                        b,
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ),
                    felts :=
                      (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                            (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                          code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                        if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                    isFailed := False, props := Map.empty,
                    vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                | none =>
                  {
                    buffers :=
                      (Map.empty[{ name := "code" : BufferVar }] ←ₘ [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                    bufferWidths :=
                      (Map.empty[{ name := "data" : BufferVar }] ←ₘ (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ (1 : ℕ),
                    cycle := (0 : ℕ),
                    felts :=
                      (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ code0)[{ name := "%0" : FeltVar }] ←ₘ
                            (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                          code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                        if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                    isFailed := True, props := Map.empty,
                    vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).bufferWidths
              { name := "data" : BufferVar } with
          | some x => x
          | none => panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ) "value is none") ∧
        (match
              if h :
                  (1 : ℕ) <
                    (match
                        if h :
                            Buffer.Idx.time
                                ((match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                    Back.toNat (0 : Back),
                                  (1 : ℕ)) <
                              List.length
                                (match
                                  (match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                    { name := "data" : BufferVar } with
                                | some x => x
                                | none =>
                                  panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                    "value is none") then
                          some
                            (match
                                (match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                  { name := "data" : BufferVar } with
                              | some x => x
                              | none =>
                                panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                  "value is none")[Buffer.Idx.time
                                ((match
                                        if
                                            (match
                                                match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds,
                                                if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                              | some a, b => a == b
                                              | none, x => false) =
                                              true then
                                          some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                        else
                                          if
                                              (match
                                                  if
                                                      (1 : ℕ) <
                                                        List.length
                                                          (Buffer.getBufferAtTime!
                                                            [[some
                                                                  (if code0 = (0 : Felt) then (1 : Felt)
                                                                  else (0 : Felt)),
                                                                none]]
                                                            (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                    some
                                                      (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                  else none with
                                                | some e => e
                                                | none => outOfBounds) =
                                                none then
                                            some
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  some
                                                    (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt)
                                                    else (0 : Felt))]]
                                          else none with
                                      | some b =>
                                        {
                                          buffers :=
                                            ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                  [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                                [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                    none]])[{ name := "data" : BufferVar }] ←ₘ
                                              b,
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := False, props := Map.empty,
                                          vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                      | none =>
                                        {
                                          buffers :=
                                            (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                          bufferWidths :=
                                            (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                                (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                              (1 : ℕ),
                                          cycle := (0 : ℕ),
                                          felts :=
                                            (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                    code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                  (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                                code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                          isFailed := True, props := Map.empty,
                                          vars :=
                                            [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                    Back.toNat (0 : Back),
                                  (1 : ℕ))]
                        else none with
                      | some e => e
                      | none => outOfBounds).length then
                some
                  (match
                      if h :
                          Buffer.Idx.time
                              ((match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).cycle -
                                  Back.toNat (0 : Back),
                                (1 : ℕ)) <
                            List.length
                              (match
                                (match
                                      if
                                          (match
                                              match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds,
                                              if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                            | some a, b => a == b
                                            | none, x => false) =
                                            true then
                                        some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                      else
                                        if
                                            (match
                                                if
                                                    (1 : ℕ) <
                                                      List.length
                                                        (Buffer.getBufferAtTime!
                                                          [[some
                                                                (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                              none]]
                                                          (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                  some
                                                    (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                                else none with
                                              | some e => e
                                              | none => outOfBounds) =
                                              none then
                                          some
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                some
                                                  (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt))]]
                                        else none with
                                    | some b =>
                                      {
                                        buffers :=
                                          ((Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                                [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                              [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                  none]])[{ name := "data" : BufferVar }] ←ₘ
                                            b,
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := False, props := Map.empty,
                                        vars := [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }
                                    | none =>
                                      {
                                        buffers :=
                                          (Map.empty[{ name := "code" : BufferVar }] ←ₘ
                                              [[some code0]])[{ name := "data" : BufferVar }] ←ₘ
                                            [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]],
                                        bufferWidths :=
                                          (Map.empty[{ name := "data" : BufferVar }] ←ₘ
                                              (2 : ℕ))[{ name := "code" : BufferVar }] ←ₘ
                                            (1 : ℕ),
                                        cycle := (0 : ℕ),
                                        felts :=
                                          (((Map.empty[{ name := "%2" : FeltVar }] ←ₘ
                                                  code0)[{ name := "%0" : FeltVar }] ←ₘ
                                                (1 : Felt))[{ name := "%13" : FeltVar }] ←ₘ
                                              code0 - (1 : Felt))[{ name := "%14" : FeltVar }] ←ₘ
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt),
                                        isFailed := True, props := Map.empty,
                                        vars :=
                                          [{ name := "code" : BufferVar }, { name := "data" : BufferVar }] }).buffers
                                  { name := "data" : BufferVar } with
                              | some x => x
                              | none =>
                                panicWithPosWithDecl "Init.Data.Option.BasicAux" "Option.get!" (16 : ℕ) (14 : ℕ)
                                  "value is none") then
                        some
                          (match
                              (match
                                    if
                                        (match
                                            match
                                              if h :
                                                  (1 : ℕ) <
                                                    List.length
                                                      (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                some
                                                  (Buffer.getBufferAtTime!
                                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                          none]]
                                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                              else none with
                                            | some e => e
                                            | none => outOfBounds,
                                            if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : Felt) with
                                          | some a, b => a == b
                                          | none, x => false) =
                                          true then
                                      some [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)), none]]
                                    else
                                      if
                                          (match
                                              if h :
                                                  (1 : ℕ) <
                                                    List.length
                                                      (Buffer.getBufferAtTime!
                                                        [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                            none]]
                                                        (Buffer.Idx.time ((0 : ℕ), (1 : ℕ)))) then
                                                some
                                                  (Buffer.getBufferAtTime!
                                                      [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                                          none]]
                                                      (Buffer.Idx.time ((0 : ℕ), (1 : ℕ))))[(1 : ℕ)]
                                              else none with
                                            | some e => e
                                            | none => outOfBounds) =
                                            none then
                                        some
                                          [[some (if code0 = (0 : Felt) then (1 : Felt) else (0 : Felt)),
                                              some (if code0 - (1 : Felt) = (0 : Felt) then (1 : Felt) else (0 : ⋯)),
                                              ⋯],
                                            ⋯]
                                      else ⋯ with
                                  | ⋯ => ⋯
                                  | ⋯ => ⋯).buffers
                                ⋯ with
                            | ⋯ => ⋯
                            | ⋯ => ⋯)[⋯]
                      else ⋯ with
                    | ⋯ => ⋯
                    | ⋯ => ⋯)[⋯]
              else ⋯ with
            | ⋯ => ⋯
            | ⋯ => ⋯).isSome =
          ⋯
error: Lean exited with code 1
Some required builds logged failures:
- Risc0.Gadgets.OneHot2.Witness.WeakestPresPart2

